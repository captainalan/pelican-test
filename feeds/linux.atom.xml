<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Alan's Miscellaneous Stuff Blog - Linux</title><link href="https://captainalan.github.io/pelican-test/" rel="alternate"></link><link href="https://captainalan.github.io/pelican-test/feeds/linux.atom.xml" rel="self"></link><id>https://captainalan.github.io/pelican-test/</id><updated>2019-12-27T00:00:00-08:00</updated><entry><title>Why LARBS?</title><link href="https://captainalan.github.io/pelican-test/why-larbs.html" rel="alternate"></link><published>2019-12-27T00:00:00-08:00</published><updated>2019-12-27T00:00:00-08:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2019-12-27:/pelican-test/why-larbs.html</id><summary type="html">&lt;p&gt;In my &lt;a href="https://captainalan.github.io/pelican-test/arch-linux-install-for-n00bs.html"&gt;Arch Linux Install for n00bs&lt;/a&gt; I gave details on how to install Arch linux and then suggested &lt;a href="https://larbs.xyz"&gt;LARBS&lt;/a&gt; as a way to get up and running with your new installation. In this article I detail &lt;em&gt;why&lt;/em&gt; I find LARBS particularly useful and address some points brought up by …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In my &lt;a href="https://captainalan.github.io/pelican-test/arch-linux-install-for-n00bs.html"&gt;Arch Linux Install for n00bs&lt;/a&gt; I gave details on how to install Arch linux and then suggested &lt;a href="https://larbs.xyz"&gt;LARBS&lt;/a&gt; as a way to get up and running with your new installation. In this article I detail &lt;em&gt;why&lt;/em&gt; I find LARBS particularly useful and address some points brought up by haters.&lt;/p&gt;
&lt;h1&gt;Sensible Defaults&lt;/h1&gt;
&lt;p&gt;The number one reason to use LARBS is to experience with &lt;strong&gt;sensible defaults
for a keyboard centered workflow&lt;/strong&gt;. LARBS offers an out-of-the-box setup of
many nice things that can take a long time to set up manually: a &lt;strong&gt;tiling
window manager&lt;/strong&gt;, vi-like &lt;strong&gt;line editing&lt;/strong&gt; (via zsh), a PDF reader (Zathura).&lt;/p&gt;
&lt;p&gt;Furthermore, LARBS comes bundled with software you probably want: e.g. a
privacy-respecting browser (Brave), git, some programming languages and
compilers. The &lt;code&gt;yay&lt;/code&gt; tool is already setup to help you grab even more software
from Arch Linux's AUR repositories.&lt;/p&gt;
&lt;h3&gt;But &lt;em&gt;real&lt;/em&gt; Linux users set these things up themselves&lt;/h3&gt;
&lt;p&gt;Practical people want good tools readily available to them. If you begin
learning guitar on a really poorly made instrument you are more likely to
become discouraged and give up. On the other hand, if you have a more
experienced friend (or shop) set up your instrument when you are getting
started, you may make a lot more progress, more quickly in &lt;em&gt;actually learning
how to play&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Furthermore, many aspects of installing things randomly often are annoying and
don't involve much learning. The arcane details of how to run some program you
are probably going to run only very rarely are perhaps better offloaded to
automation (e.g. the shell scripts LARBS uses).&lt;/p&gt;
&lt;h3&gt;But using someone else's setup is lame!&lt;/h3&gt;
&lt;p&gt;LARBS does not constrain how you set things up later---it's just a shell script
to get you started.&lt;/p&gt;
&lt;p&gt;For instance, I use emacs a lot, and Luke Smith (who made LARBS) doesn't. Many
tools in LARBS I don't care about or use (e.g. &lt;code&gt;vifm&lt;/code&gt;, vim-like file manager)
because I just use &lt;code&gt;dired&lt;/code&gt; in emacs.&lt;/p&gt;
&lt;h1&gt;Pros and Cons&lt;/h1&gt;
&lt;h2&gt;What LARBS is &lt;em&gt;not&lt;/em&gt; good for&lt;/h2&gt;
&lt;p&gt;Obviously, if you require applications that require Windows or some other OS, you are out of luck.&lt;/p&gt;
&lt;p&gt;If you are doing complicated things with sound, hardware, etc. LARBS only gives a basic desktop setup. It may be much harder to adjust these settings in LARBS compared with a well-established Linux distribution, such as Lubuntu or Manjaro (two others I have tried with older hardware).&lt;/p&gt;
&lt;p&gt;It is hard to set up typing in CJK; I'm still figuring out how to get this well
integrated and will upload a guide when I am able to do so nicely.&lt;/p&gt;
&lt;h2&gt;What LARBS &lt;em&gt;is&lt;/em&gt; good for&lt;/h2&gt;
&lt;p&gt;LARBS is good for getting a decent general computing and programming
environment set up quickly.&lt;/p&gt;
&lt;p&gt;For a user coming from a more traditional desktop setup, LARBS allows you to
explore ideas like...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tiling windows for more efficient screen space usage&lt;/li&gt;
&lt;li&gt;Remapping CAPS LOCK for happier keyboarding&lt;/li&gt;
&lt;li&gt;Editing config files to change settings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;...without the trouble that might come from tweaking another installation (e.g.
modifying default Ubuntu) or doing everything from scratch.&lt;/p&gt;
&lt;p&gt;While on the one hand, there is definitely learning to be done in &lt;em&gt;doing&lt;/em&gt;
things yourself from the start, why shouldn't we reuse good defaults and stable
software set up by more knowledgable people? Studying the LARBS config files is
a good way to start writing your own configs.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;If you wanna try out a tilling window manager, just install Arch and LARBS. It
is not even that bad and you can customize it more later as you find out more
about what you want.&lt;/p&gt;</content><category term="Linux"></category></entry><entry><title>Getting Comfortable with Linux</title><link href="https://captainalan.github.io/pelican-test/getting-comfortable-with-linux.html" rel="alternate"></link><published>2019-08-14T00:00:00-07:00</published><updated>2019-08-14T00:00:00-07:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2019-08-14:/pelican-test/getting-comfortable-with-linux.html</id><summary type="html">&lt;p&gt;Updated 8/14/2019&lt;/p&gt;
&lt;h2&gt;This tutorial&lt;/h2&gt;
&lt;p&gt;This tutorial aims to answer this question:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Now that I have a Linux system running, how do I go about learning
more?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This tutorial is aimed at eager beginners and aspiring computer users
that have decided to take control of their computing. It largely …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Updated 8/14/2019&lt;/p&gt;
&lt;h2&gt;This tutorial&lt;/h2&gt;
&lt;p&gt;This tutorial aims to answer this question:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Now that I have a Linux system running, how do I go about learning
more?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This tutorial is aimed at eager beginners and aspiring computer users
that have decided to take control of their computing. It largely
follows my journey to learn more about Linux specifically and
computing more generally. My goal is that with this tutorial and a
handful of things downloaded, you can sit with your
computer&amp;mdash;even without an Internet connection and learn more
about computing.&lt;/p&gt;
&lt;p&gt;My approach here is thematic; I go over some class of actions you
might want to do, and then mention some options you may choose to
succeed at doing these things.&lt;/p&gt;
&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;p&gt;In this tutorial, I assume that you have a Linux system up and running
(...and here, the term "Linux" is used to mean a UNIX or UNIX-like
system that has certain core utilities, &lt;em&gt;not&lt;/em&gt; the kernel itself or
something highly technical like that). For something that just works,
&lt;a href="https://manjaro.org/"&gt;Manjaro&lt;/a&gt; and &lt;a href="https://xubuntu.org/"&gt;Xubuntu&lt;/a&gt;
are some solid options. If you want to spend some more time
configuring things, you may want to try &lt;a href="https://captainalan.github.io/pelican-test/"&gt;installing Arch
Linux&lt;/a&gt;. Really, it
doesn't matter that much where you start because you are entering
Linux land where customizability is king.&lt;/p&gt;
&lt;h3&gt;Editors&lt;/h3&gt;
&lt;p&gt;What is a samurai without a sword? You need an editor! Most things on
Linux are configurable via a &lt;strong&gt;"dot file"&lt;/strong&gt;, so called because they
have a name that starts with a &lt;em&gt;dot&lt;/em&gt; (e.g. &lt;code&gt;.bashrc&lt;/code&gt;,
&lt;code&gt;.eslint&lt;/code&gt;...). You will need an editor to change these files. If you
are enthusiastic about learning Linux, you probably have some interest
in writing scripts or programs or some sort. You'll need an editor for
that too.&lt;/p&gt;
&lt;p&gt;Learning the basics of some editor is a skill you will not
regret. Editors like &lt;code&gt;vi&lt;/code&gt; and &lt;code&gt;nano&lt;/code&gt; can be found pretty much
anywhere. It probably won't be too difficult for you to grab a more
sophisticated editor like &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;emacs&lt;/code&gt;, or Visual Studio Code.&lt;/p&gt;
&lt;h2&gt;The GUI way&lt;/h2&gt;
&lt;p&gt;There is a big movement to make Linux systems intuitive and
"user-friendly", particularly for users coming from Windows and
Mac. No explanations needed here&amp;mdash;you can explore the menus and
built in softwares with any Linux distribution that comes built in
with a graphical desktop environment. &lt;/p&gt;
&lt;p&gt;There is no shame in using and enjoying a GUI. For many things, this
is the easiest way to get things done, particularly if you don't care
to do any special configuration. Examples of things I've recently used
GUI menus to configure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Themes/fonts&lt;/li&gt;
&lt;li&gt;Wallpaper&lt;/li&gt;
&lt;li&gt;Keyboard shortcuts&lt;/li&gt;
&lt;li&gt;Joining wifi networks&lt;/li&gt;
&lt;li&gt;Sound/volume stuff&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Other tasks, such as managing software, is perhaps better done through
the Command Line Interface (CLI).&lt;/p&gt;
&lt;h2&gt;Whispering into the soul of your system&lt;/h2&gt;
&lt;p&gt;Lots of things on modern computers are "artifacts of engineering",
leftover remnants from designs of the past. One interesting example is
the "command line interface" typically accessed through a &lt;strong&gt;terminal&lt;/strong&gt;
(emulator).&lt;/p&gt;
&lt;p&gt;Computers used to look like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Computer Terminal" src="https://live.staticflickr.com/3708/10526021063_a47c368729_b.jpg"&gt;
&lt;p style="font-size: 0.9rem;font-style: italic;"&gt;&lt;a href="https://www.flickr.com/photos/15528623@N00/10526021063"&gt;"IMG_20131027_152921"&lt;/a&gt;&lt;span&gt;by &lt;a href="https://www.flickr.com/photos/15528623@N00"&gt;S. F.&lt;/a&gt;&lt;/span&gt; is licensed under &lt;a href="https://creativecommons.org/licenses/by-nc-sa/2.0/?ref=ccsearch&amp;atype=html" style="margin-right: 5px;"&gt;CC BY-NC-SA 2.0&lt;/a&gt;&lt;a href="https://creativecommons.org/licenses/by-nc-sa/2.0/?ref=ccsearch&amp;atype=html" target="_blank" rel="noopener noreferrer" style="display: inline-block;white-space: none;opacity: .7;margin-top: 2px;margin-left: 3px;height: 22px !important;"&gt;&lt;img style="height: inherit;margin-right: 3px;display: inline-block;" src="https://search.creativecommons.org/static/img/cc_icon.svg" /&gt;&lt;img style="height: inherit;margin-right: 3px;display: inline-block;" src="https://search.creativecommons.org/static/img/cc-by_icon.svg" /&gt;&lt;img style="height: inherit;margin-right: 3px;display: inline-block;" src="https://search.creativecommons.org/static/img/cc-nc_icon.svg" /&gt;&lt;img style="height: inherit;margin-right: 3px;display: inline-block;" src="https://search.creativecommons.org/static/img/cc-sa_icon.svg" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;In more current times, the old way of interacting with computers is
emulated using what is usually called something like "terminal" or
"shell" on modern systems.&lt;/p&gt;
&lt;h3&gt;Need moar software&lt;/h3&gt;
&lt;p&gt;Most Linux distributions ship with a &lt;strong&gt;package manager&lt;/strong&gt;. &lt;/p&gt;
&lt;h3&gt;Exploring your filesystem&lt;/h3&gt;
&lt;p&gt;Typing stuff like &lt;code&gt;ls -la&lt;/code&gt; all the time can get very tiring. One way
to get around this problem is to define &lt;strong&gt;aliases&lt;/strong&gt; for commands you
commonly use.&lt;/p&gt;
&lt;p&gt;Another way to get around your file sytem is to use a &lt;strong&gt;file manager&lt;/strong&gt;
that runs on the command line (or within your favorite editor). For
example, there is &lt;a href="https://vifm.info/"&gt;&lt;code&gt;vifm&lt;/code&gt;&lt;/a&gt; for doing common
operations like moving, copying, and renaming files in a vim editor
like way. Emacs has the built in
&lt;a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html"&gt;&lt;code&gt;dired&lt;/code&gt;&lt;/a&gt;
mode to do these things.&lt;/p&gt;
&lt;h3&gt;Getting system info&lt;/h3&gt;
&lt;p&gt;To find out some quick information about your system and display it in
a pretty way, use your package manager to download and install
&lt;code&gt;screenfetch&lt;/code&gt;. There are of course other places to find all of this
information, but this is the easiest way to getting system info (that
also looks cool) akin to doing the "about my computer" stuff on
Windows or MacOS.&lt;/p&gt;
&lt;h2&gt;Finding more information&lt;/h2&gt;
&lt;p&gt;Are there things that you don't understand? How do you find
documentation for those things?&lt;/p&gt;
&lt;h3&gt;Clicking through menus&lt;/h3&gt;
&lt;p&gt;This is often how I learn more about the features of some program. You
may discover useful commands you never thought you needed if you take
the time to click through some menus.&lt;/p&gt;
&lt;p&gt;I've found this especially helpful in using widely used, large,
complex programs like GIMP (image manipulation) and Blender (3D
graphics).&lt;/p&gt;
&lt;h3&gt;Built-in help systems&lt;/h3&gt;
&lt;p&gt;Many pieces of software come with their own built in help
systems. Many (most?) users jump to searching the Internet for
answers, but becoming familiar with the built-in help system for some
software may be able to provide quicker, more specific answers if you
invest a little bit of time to learn how to use it.&lt;/p&gt;
&lt;p&gt;Documentation is often available for download for offline viewing. If
you have a 12 hour flight coming up, why not read a user manual until
you fall asleep? (either way, you win&amp;mdash;you learn something or you
get a good rest).&lt;/p&gt;
&lt;h3&gt;High quality online resources&lt;/h3&gt;
&lt;p&gt;Not all websites are created equal; finding the best websites can save
you a lot of time you'd otherwise spend sifting through crap.&lt;/p&gt;
&lt;p&gt;Rather than naïvely Googling how to do something on Linux, for
instance, it may be helpful to first consult the &lt;a href="https://wiki.archlinux.org/"&gt;Arch
Wiki&lt;/a&gt; for Linux related topics. This
resource can be useful even for non-Arch users that want to learn
about some topic and Linux. For instance, recently I wanted to see
what options were available for &lt;a href="https://wiki.archlinux.org/index.php/Optical_disc_drive#Ripping"&gt;ripping
CDs&lt;/a&gt;. The
Arch Wiki had lots of helpful information for doing that on my
(non-Arch) Debian-based system.&lt;/p&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://xahlee.info/linux/linux_index.html"&gt;Practical Linux Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="Linux"></category></entry><entry><title>Arch Linux Install for n00bs</title><link href="https://captainalan.github.io/pelican-test/arch-linux-install-for-n00bs.html" rel="alternate"></link><published>2019-06-02T00:00:00-07:00</published><updated>2019-06-02T00:00:00-07:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2019-06-02:/pelican-test/arch-linux-install-for-n00bs.html</id><summary type="html">&lt;p&gt;In this tutorial, I will go through installing Arch Linux. These
instructions were tried out on both a virtual machine and an old
laptop. For further instructions and details, I recommend &lt;em&gt;resisting
the urge to reflexively search everything&lt;/em&gt;, and instead taking the
time to read through high-quality resources, such as …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this tutorial, I will go through installing Arch Linux. These
instructions were tried out on both a virtual machine and an old
laptop. For further instructions and details, I recommend &lt;em&gt;resisting
the urge to reflexively search everything&lt;/em&gt;, and instead taking the
time to read through high-quality resources, such as the (official)
Arch Wiki &lt;a href="https://wiki.archlinux.org/index.php/Installation_guide"&gt;installation
guide&lt;/a&gt;.  That
being said, the content in this article should be sufficient to get an
Arch System up and running&amp;em;I've used it multiple times to help me
setup new systems.&lt;/p&gt;
&lt;p&gt;I am closely following &lt;a href="https://www.youtube.com/watch?v=4PBqpX0_UOc"&gt;Full Arch Linux Install (SAVAGE Edition!)
Linux&lt;/a&gt; by Luke Smith (March 8,
2018).&lt;/p&gt;
&lt;p&gt;We will do a base installation of Arch Linux. Then we'll run &lt;a href="https://lukesmith.xyz"&gt;Luke
Smith's&lt;/a&gt; &lt;a href="https://larbs.xyz/"&gt;LARBS&lt;/a&gt; script to
get an awesome i3 tiling window manager setup from the outset.  (TODO:
Also -&amp;gt; Add instructions/links to a &lt;strong&gt;NEW&lt;/strong&gt; tutorial about getting a
Desktop Environment, emacs, etc. and choosing a different path).&lt;/p&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;This tutorial is aimed at people with some exposure to Linux and/or command
line tools (e.g. using &lt;code&gt;brew&lt;/code&gt; under MacOS), but who would like to gain
greater control of their current computing setups. Here, I honor the maxim
that &lt;em&gt;knowledge is power&lt;/em&gt; and seek to empower you by getting you started
using Arch Linux and understanding the tools that you are using.&lt;/p&gt;
&lt;p&gt;You should know how to do basic things with &lt;code&gt;vi&lt;/code&gt; (or &lt;code&gt;vim&lt;/code&gt;, or some
other editor readily available in the
&lt;a href="https://en.wikipedia.org/wiki/Computer_terminal#Text_terminals"&gt;TTY&lt;/a&gt;,
such as &lt;code&gt;nano&lt;/code&gt;) because doing an Arch install will involve editing
some text files on the command line.&lt;/p&gt;
&lt;h2&gt;Installation Medium&lt;/h2&gt;
&lt;p&gt;Download the latest Arch linux ISO. The easiest thing to do is probably to
download from an HTTP mirror near your (physical) location and then install by CD, DVD, or USB.&lt;/p&gt;
&lt;p&gt;From Windows, creating your installation medium is easy. Right click
on the downloaded &lt;code&gt;.iso&lt;/code&gt; file and select "Burn disc image" to create
CD or DVD to create a your installation medium. Alternatively, you can
use &lt;a href="https://rufus.ie/"&gt;Rufus&lt;/a&gt; on Windows to create install media on
USB drives, SD cards, and more.&lt;/p&gt;
&lt;h2&gt;Booting with the installation medium&lt;/h2&gt;
&lt;p&gt;Restart your computer. You may have to go into your system BIOS to make sure you can boot from your installation medium.&lt;/p&gt;
&lt;h3&gt;Get an internet connection&lt;/h3&gt;
&lt;p&gt;If you are already connected to the Internet via an ethernet cable, there is
nothing to think about. If you are connecting via Wi-Fi, run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;wifi-menu
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I can't help you anymore if you are connecting from McDonald's wifi... But on
a home network, you will be prompted for your Wi-Fi network's password.
Once you go through the options &lt;code&gt;wifi-menu&lt;/code&gt;, try out your network connection
with something like &lt;code&gt;ping google.com&lt;/code&gt;. Type &lt;code&gt;ctrl-c&lt;/code&gt; to exit when you are
done.&lt;/p&gt;
&lt;h3&gt;Time and date stuff&lt;/h3&gt;
&lt;p&gt;Run &lt;code&gt;timedatectl set-ntp true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note the 'prefix' &lt;em&gt;-ctl&lt;/em&gt; in the command above. Commands with &lt;em&gt;-ctl&lt;/em&gt;
have to do with &lt;em&gt;controlling&lt;/em&gt; system processes. A command we will see
later is
&lt;a href="https://wiki.archlinux.org/index.php/Systemd#Basic_systemctl_usage"&gt;&lt;code&gt;systemctl&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Partitioning your drive(s)&lt;/h2&gt;
&lt;p&gt;Now, let's partition our disks. &lt;strong&gt;Note&lt;/strong&gt;: I am assuming you are
installing Arch Linux on a computer you are OK with deleting all data
on. Go reboot and back up your files and stuff if you are not ready to
proceed yet.&lt;/p&gt;
&lt;p&gt;In any case you can, run &lt;code&gt;lsblk&lt;/code&gt; (or &lt;code&gt;fdisk -l&lt;/code&gt;) to "list all block
devices".&lt;/p&gt;
&lt;h3&gt;Creating new partitions&lt;/h3&gt;
&lt;p&gt;From &lt;code&gt;lsblk&lt;/code&gt;, you can identify the drive you want to install Arch Linux on.
This will probably be &lt;code&gt;/dev/sda&lt;/code&gt; if you are installing onto an old computer.&lt;/p&gt;
&lt;p&gt;Let's start changing things.  To begin, type &lt;code&gt;fdisk /dev/sda&lt;/code&gt;, where
'"&lt;code&gt;sda&lt;/code&gt;" corresponds to the &lt;strong&gt;drive&lt;/strong&gt; you wish to create a new
partition table on (don't do &lt;code&gt;fdisk /dev/sda123&lt;/code&gt;; this won't
work&amp;em;go ahead and try that if you don't believe me!).&lt;/p&gt;
&lt;p&gt;You will now be sent to a new prompt that looks something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Command (m for help):&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If there are existing partitions you may need to type &lt;code&gt;d&lt;/code&gt; to delete them.
Type &lt;code&gt;p&lt;/code&gt; to print partitions. Once you are done deleting existing stuff, type
&lt;code&gt;n&lt;/code&gt; at the prompt to make a new partition.&lt;/p&gt;
&lt;p&gt;We will now create the following partitions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boot partition (200MB)&lt;/li&gt;
&lt;li&gt;SWAP partition (how much RAM you have, times 1.5)&lt;/li&gt;
&lt;li&gt;Root (25 GB or more)&lt;/li&gt;
&lt;li&gt;Home (everything else)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After typing &lt;code&gt;n&lt;/code&gt;, you will be be prompted with a number of options. To create
the Boot partition, accept the first default option (&lt;code&gt;p&lt;/code&gt;) to create a new
primary partition. Accept &lt;code&gt;1&lt;/code&gt; as the default partition number. Accept the
default "First sector" location. For the "Last sector", enter &lt;code&gt;+200M&lt;/code&gt;. This means will be the &lt;em&gt;boot&lt;/em&gt; partition which we are allocating 200 MB for.&lt;/p&gt;
&lt;p&gt;Next, we will craete a &lt;strong&gt;swap partition&lt;/strong&gt;. Type &lt;code&gt;n&lt;/code&gt; again to get started.
Standard practice is to create a swap partition of about 1.5-2 times the
amount of RAM you have. I'll be using 4 GB for this. Accept the default
partion number (probably 2), default first sector, and for the last sector do
&lt;code&gt;+4G&lt;/code&gt; (where you replace "4" with however much memory you select for your
swap partition).&lt;/p&gt;
&lt;p&gt;We will now create a &lt;strong&gt;root partition&lt;/strong&gt; where all your programs will be
installed. A reasonable starting size for this is around 25 GB, though you
may need more if you like to install a lot of programs. I'll be using 64 GB.
Typing &lt;code&gt;n&lt;/code&gt; (and then pressing Enter), I accept the default for the partiton
number and the starting sector and then select &lt;code&gt;+64G&lt;/code&gt; for the last sector.&lt;/p&gt;
&lt;p&gt;Finally, we need to create a &lt;strong&gt;home partition&lt;/strong&gt; which will take up the rest
of your disk. Do &lt;code&gt;n&lt;/code&gt; for a new partition and then selct &lt;code&gt;p&lt;/code&gt; (rather than &lt;code&gt;e&lt;/code&gt;)
to create a new primary partition. Then, accept all the defaults that follow.&lt;/p&gt;
&lt;p&gt;We have now created four nice partitions using &lt;code&gt;fdisk&lt;/code&gt;. However, these are
not "commited" to disk yet. Write &lt;code&gt;w&lt;/code&gt; at the &lt;code&gt;Command (m for help):&lt;/code&gt; prompt
to write your partitions to your disk. Note that this will wipe everything on the disk.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; since we partitioned our disk, you can easily install a different linux distribution if you wanted; just re-write the &lt;code&gt;root&lt;/code&gt; partition and all your &lt;code&gt;home&lt;/code&gt; files will still be there.&lt;/p&gt;
&lt;p&gt;Type &lt;code&gt;lsblk&lt;/code&gt; to see how &lt;code&gt;fdisk&lt;/code&gt; changed your harddirve.&lt;/p&gt;
&lt;h2&gt;Making filesystems&lt;/h2&gt;
&lt;p&gt;We just partitioned our disks, but we need to set &lt;strong&gt;filesystems&lt;/strong&gt; to our
partitions.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;boot&lt;/code&gt;, &lt;code&gt;root&lt;/code&gt;, and &lt;code&gt;home&lt;/code&gt; partition (&lt;code&gt;sda1&lt;/code&gt;, &lt;code&gt;sda3&lt;/code&gt;, and &lt;code&gt;sda4&lt;/code&gt; if you
have been following the tutorial for) should be formatted to &lt;code&gt;ext4&lt;/code&gt;, a Linux
standard.&lt;/p&gt;
&lt;p&gt;Do &lt;code&gt;mkfs.ext4 /dev/sda1&lt;/code&gt;, &lt;code&gt;mkfs.ext4 /dev/sda3&lt;/code&gt;, and &lt;code&gt;mkfs.ext4 /dev/sda4&lt;/code&gt; to
set these partitions' filesystems.&lt;/p&gt;
&lt;p&gt;Now, for the swap partition do &lt;code&gt;mkswap /dev/sda2&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Mounting stuff&lt;/h2&gt;
&lt;p&gt;Now that we have created partitions with appropriate filesystems, we need to
&lt;strong&gt;mount&lt;/strong&gt; things.&lt;/p&gt;
&lt;p&gt;First, do &lt;code&gt;mount /dev/sda3 /mnt&lt;/code&gt; to mount your root partition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; at any point during this tutorial you may want to run &lt;code&gt;lsblk&lt;/code&gt; to see
*how your disks currently look.&lt;/p&gt;
&lt;p&gt;Type &lt;code&gt;ls /mnt&lt;/code&gt;. You should see something like &lt;code&gt;lost+found&lt;/code&gt; there.&lt;/p&gt;
&lt;p&gt;Let's make make some new directories to mount stuff. First do
&lt;code&gt;mkdir /mnt/boot&lt;/code&gt; create a mount point for our boot partition. Then, run
&lt;code&gt;mount /dev/sda1 /mnt/boot&lt;/code&gt; to do the actual mounting.&lt;/p&gt;
&lt;p&gt;Finally, do &lt;code&gt;mkdir /mnt/home&lt;/code&gt;. Run &lt;code&gt;mount /dev/sda4 /mnt/home&lt;/code&gt; to mount your
home partition.&lt;/p&gt;
&lt;h2&gt;Installing the base system&lt;/h2&gt;
&lt;p&gt;We now have all of our partitions and have mounted these partitions on our
file systems. Mounting allows us to modify the data on these partitions,
which means we can install softare (like Arch Linux!).&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;lsblk&lt;/code&gt; to see that all is as it should be.&lt;/p&gt;
&lt;h3&gt;The fun starts with &lt;code&gt;pacstrap&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Run &lt;code&gt;pacstrap /mnt base base-devel&lt;/code&gt; to install the base package and basic
development tools. If you want more things, add them like so to this command.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update December 8, 2019&lt;/strong&gt;: You may want to also install &lt;code&gt;linux&lt;/code&gt; and
&lt;code&gt;linux-firmware&lt;/code&gt; to make sure the latest Linux kernel and appropriate drivers
respectively are installed. Do this &lt;em&gt;before&lt;/em&gt; you install &lt;code&gt;grub&lt;/code&gt; (directions
below) or else you may not be able to boot your new installation.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pacstrap /mnt base base-devel vim emacs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Running this command might take a while because it is installing an entire
base system.&lt;/p&gt;
&lt;h2&gt;Making an &lt;code&gt;fstab&lt;/code&gt; file&lt;/h2&gt;
&lt;p&gt;Earlier, we mounted a bunch of partitions manually. An &lt;code&gt;fstab&lt;/code&gt; file tells
Linux what to try to load (see &lt;code&gt;etc/fstab&lt;/code&gt;). Run &lt;code&gt;genfstab /mnt&lt;/code&gt;. This will
generate an &lt;code&gt;fstab&lt;/code&gt; file based on how &lt;code&gt;mnt&lt;/code&gt; looks. Running this command will
just output a bunch of stuff.&lt;/p&gt;
&lt;p&gt;We need to save these things to a file. Run
&lt;code&gt;genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now Arch Linux will know what goes where.&lt;/p&gt;
&lt;h2&gt;Making our installation bootable&lt;/h2&gt;
&lt;p&gt;Run &lt;code&gt;arch-chroot /mnt&lt;/code&gt; to change our root. This will change our Arch root to
our new &lt;code&gt;/mnt&lt;/code&gt; directory! Before, we were running from our installation
medium, now we are running from our actual installation!&lt;/p&gt;
&lt;h3&gt;I needs Interwebs&lt;/h3&gt;
&lt;p&gt;Let's install some stuff. First, let's install &lt;code&gt;NetworkManager&lt;/code&gt; by typing &lt;code&gt;pacman -S networkmanager&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, type &lt;code&gt;systemctl enable NetworkManager&lt;/code&gt; to start &lt;code&gt;NetworkManager&lt;/code&gt;
whenever you log in.&lt;/p&gt;
&lt;h3&gt;GRUB Bootloader&lt;/h3&gt;
&lt;p&gt;Run &lt;code&gt;pacman -S grub&lt;/code&gt; to install GRUB, our bootloader. This is important!&lt;/p&gt;
&lt;p&gt;After this finishes, run &lt;code&gt;grub-install --target=i386-pc /dev/sda&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Once this is done, do &lt;code&gt;grub-mkconfig -o /boot/grub/grub.cfg&lt;/code&gt; to make a config
file. (This might be done automatically.)&lt;/p&gt;
&lt;h3&gt;Setting a password&lt;/h3&gt;
&lt;p&gt;Run &lt;code&gt;passwd&lt;/code&gt; to set a root password.&lt;/p&gt;
&lt;h3&gt;Setting a locale&lt;/h3&gt;
&lt;p&gt;Use your text editor (here I use &lt;code&gt;vim&lt;/code&gt;) to edit &lt;code&gt;/etc/locale.gen&lt;/code&gt;. I do this
with &lt;code&gt;vim /etc/locale.gen&lt;/code&gt;. In this huge list of locales I uncommented&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#en_US.UTF-8 UTF-8&lt;/span&gt;
&lt;span class="err"&gt;#en_US ISO-8859-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;en_US.UTF-8 UTF-8&lt;/span&gt;
&lt;span class="err"&gt;en_US ISO-8859-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...in order to set my locale. Note, you can set multiple languages. Save and
exit this file.&lt;/p&gt;
&lt;p&gt;Next, run &lt;code&gt;locale-gen&lt;/code&gt; to read the conf file you just edited and generate a
file.&lt;/p&gt;
&lt;p&gt;Let's edit one more file to set our (default) language: &lt;code&gt;vim
/etc/locale.conf&lt;/code&gt;. I changed the contents of this file to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;LANG=en_US.UTF-8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Setting a timezone&lt;/h3&gt;
&lt;p&gt;By default, in &lt;code&gt;/etc/localtime&lt;/code&gt;, there are a bunch of time zones. We want to
link &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt; with our timezone.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;ln -sf /usr/share/zoneinfo/America/Los_Angeles /etc/localtime&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...where of course you replace &lt;code&gt;.../America/Los_Angles...&lt;/code&gt; with where you are.&lt;/p&gt;
&lt;p&gt;If you travel somewhere else, you will rerun the &lt;code&gt;ln...&lt;/code&gt; command here to the
timezone of wherever you are going.&lt;/p&gt;
&lt;h3&gt;Setting a hostname&lt;/h3&gt;
&lt;p&gt;Finally, you need to set a name for your computer. Edit &lt;code&gt;/etc/hostname&lt;/code&gt; to
whatever you like. I will do &lt;code&gt;vim /etc/hostname&lt;/code&gt; and enter &lt;code&gt;arch-sama&lt;/code&gt; for a (weeby) hostname.&lt;/p&gt;
&lt;h3&gt;Going back to your installation medium...&lt;/h3&gt;
&lt;p&gt;Type &lt;code&gt;exit&lt;/code&gt; to go back to your installation medium.&lt;/p&gt;
&lt;p&gt;Then, to be safe type &lt;code&gt;umount -R /mnt&lt;/code&gt; to unmount your Arch installation (on
your harddrive).&lt;/p&gt;
&lt;h3&gt;Reboot!&lt;/h3&gt;
&lt;p&gt;Type &lt;code&gt;reboot&lt;/code&gt;. Remove your installation medium. You should boot to your new
installation.&lt;/p&gt;
&lt;h2&gt;LARBS&lt;/h2&gt;
&lt;p&gt;Here is the easy part. To get a pretty cool configuration right away, use
Luke Smith's &lt;a href="https://larbs.xyz"&gt;LARBS&lt;/a&gt; setup.&lt;/p&gt;
&lt;p&gt;Booting your new Arch setup, login as &lt;code&gt;root&lt;/code&gt;. You'll be prompted for your
password.&lt;/p&gt;
&lt;p&gt;Next, run&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;curl -LO larbs.xyz/larbs.sh  &lt;span class="c1"&gt;# Download the script&lt;/span&gt;
bash larbs.sh                &lt;span class="c1"&gt;# Run the script you just downloaded!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Logging in&lt;/h3&gt;
&lt;p&gt;Login with the username and password you set in LARBS. To modify your system,
you'll probably need to use &lt;code&gt;su&lt;/code&gt; and the password you set for root in the
Arch install.&lt;/p&gt;
&lt;h3&gt;Troubleshooting LARBS install&lt;/h3&gt;
&lt;p&gt;If you aren't connected to the Internet, this step can be a pain in the ass.
Search the Arch Wiki for wisdom.&lt;/p&gt;
&lt;p&gt;If you run into issues with &lt;code&gt;xorg&lt;/code&gt;, search for answers related to your graphics
card. Using an older (around 2010) laptop with an NVIDIA graphics card, I had
to install the Nouveau drivers.&lt;/p&gt;
&lt;h2&gt;Checking your new system out&lt;/h2&gt;
&lt;p&gt;Make sure your &lt;code&gt;/etc/fstab&lt;/code&gt; came out correctly.&lt;/p&gt;
&lt;p&gt;Running &lt;code&gt;htop&lt;/code&gt; I found out that my SWAP partition wasn't being used
after following the above steps. Easy way to get SWAP working was to
install gparted (&lt;code&gt;sudo pacman -Syu gparted&lt;/code&gt;) and launch that (&lt;code&gt;sudo
gparted&lt;/code&gt;), then make sure the swap partiton I created had &lt;code&gt;SWAPON&lt;/code&gt;
(find option in menus). You can then &lt;code&gt;sudo swapon --show&lt;/code&gt; to see that
things are working correctly.&lt;/p&gt;
&lt;h3&gt;Hard Drive Related Troubleshooting&lt;/h3&gt;
&lt;h3&gt;Boot issues&lt;/h3&gt;
&lt;p&gt;In this article, I used an "old-school" style of partitioning drives, mounting
partitions, etc.  If you are having trouble booting, you may need to go into
your BIOS to make sure you are booting devices in the correct order. You may
also want to check that your &lt;code&gt;/boot&lt;/code&gt; directory (mounted to its own partition,
hopefully) is bootable. Look up how to add a boot &lt;strong&gt;flag&lt;/strong&gt; to do this. Two ways
are to use the &lt;code&gt;fdisk&lt;/code&gt; util introduced at the beginning of this tutorial, or do
get an install for another distro (e.g. Ubuntu) and use the graphical tools
(e.g. gparted) to assist you in doing that.&lt;/p&gt;
&lt;h4&gt;Messed up partitons?&lt;/h4&gt;
&lt;p&gt;I used the article "&lt;a href="https://www.tecmint.com/move-home-directory-to-new-partition-disk-in-linux/"&gt;move your home directory to a new partiton&lt;/a&gt;" as a guide. The same approach here can be used for all sorts of directory and partition shuffling.&lt;/p&gt;
&lt;p&gt;The basic procedure to move your &lt;code&gt;/home/&lt;/code&gt; to a new partition is to&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;create a new partition,&lt;/li&gt;
&lt;li&gt;copy your existing &lt;code&gt;/home&lt;/code&gt; directory there and verify this operation succeeded,&lt;/li&gt;
&lt;li&gt;remove the old files you just copied,&lt;/li&gt;
&lt;li&gt;mount the copied files on the correct (new) partition to &lt;code&gt;/home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;save your configuration in &lt;code&gt;/etc/fstab&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These operations will require &lt;code&gt;su&lt;/code&gt; permissions (e.g. through using &lt;code&gt;sudo&lt;/code&gt;).&lt;/p&gt;</content><category term="Linux"></category></entry><entry><title>Practical Shell Scripting, Part 1</title><link href="https://captainalan.github.io/pelican-test/practical-shell-scripting-part-1.html" rel="alternate"></link><published>2019-05-19T00:00:00-07:00</published><updated>2019-05-19T00:00:00-07:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2019-05-19:/pelican-test/practical-shell-scripting-part-1.html</id><summary type="html">&lt;p&gt;In this series of articles, I will document how I do various things
using shell scripts&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.  My basic approach is to use &lt;code&gt;bash&lt;/code&gt; to
automate stuff by documenting and replicating steps that I take on the
&lt;strong&gt;Command Line Interface&lt;/strong&gt; (CLI) &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;Preliminary things&lt;/h2&gt;
&lt;p&gt;It is assumed the reader has …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this series of articles, I will document how I do various things
using shell scripts&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.  My basic approach is to use &lt;code&gt;bash&lt;/code&gt; to
automate stuff by documenting and replicating steps that I take on the
&lt;strong&gt;Command Line Interface&lt;/strong&gt; (CLI) &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;Preliminary things&lt;/h2&gt;
&lt;p&gt;It is assumed the reader has basic working knowledge of doing things
like navigating around directories, deleting files, using some editor,
etc. No knowledge is assumed of using specific tools like &lt;code&gt;find&lt;/code&gt;,
&lt;code&gt;xargs&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt;, etc. Much of the content here will be treating how to
do useful things using those tools.&lt;/p&gt;
&lt;h3&gt;Additional Setup&lt;/h3&gt;
&lt;p&gt;There is a utility called &lt;a href="https://www.shellcheck.net/"&gt;ShellCheck&lt;/a&gt;
which may be helpful to set up with your favorite editor/development
environment. This tool can help you find common mistakes in your shell
script code &lt;em&gt;before&lt;/em&gt; you even try to run it.&lt;/p&gt;
&lt;h3&gt;Methodology&lt;/h3&gt;
&lt;p&gt;When there is something that I want to do (on Linux), I'll try to do
it all via the command line. Anything non-trivial that I might have to
do again I'll want to document somewhere so I don't have to bother
figuring out the annoying aspects again. Comments can be written to
explain non-obvious choices.&lt;/p&gt;
&lt;h2&gt;Shell Scripts as Duct Tape&lt;/h2&gt;
&lt;p&gt;First, my "User Philosophy"!&lt;/p&gt;
&lt;p&gt;On your computer, you have many programs that can individually do
useful things. Shell scripting is the &lt;em&gt;de facto&lt;/em&gt; way to smash a bunch
of programs together to do more complex tasks for you.&lt;/p&gt;
&lt;p&gt;Shell scripting is different from "programing" in the sense that you
are often dealing with relatively high-level structures, understanding
&lt;em&gt;what&lt;/em&gt; programs do without needing to concern yourself with &lt;em&gt;how&lt;/em&gt; they
do it. In this way, you leave it up to the "real programers" to take
care of things like optimizing their programs to be efficient. Your
job is to just make sure that things hold together "good enough" with
duct tape.&lt;/p&gt;
&lt;p&gt;Over time you can refine your programs to be better. What is most
important is to get the job done and not get to hung up on what is
best. It is better to write more shell scripts, gradually learning
what is "best" among the many options to do things than to get hung up
on some esoteric problem too long.&lt;/p&gt;
&lt;p&gt;Careful engineering is the realm of using more full-featured,
complexity-friendly programing languages. You can write programs in
other languages and call them from shell-scripts if you have to do
something particularly complicated that your default tools cannot
handle so well (e.g. write a parser for a new custom file format you
created).&lt;/p&gt;
&lt;h2&gt;Where's my Search Bar?&lt;/h2&gt;
&lt;p&gt;MacOS has a fancy search feature you can use by pressing COMMAND+SPACE
by default. When you do this, you can type words, and MacOS will scan
your computer in who-knows-what-way for the text you are entering and
stuff the OS guesses might be related. Windows Explorer has similar
search features too, I think. How do you do something similar on
Linux? &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Suppose, we want to list all the Markdown files in a directory (&lt;code&gt;.md&lt;/code&gt;
extension). Using &lt;code&gt;find&lt;/code&gt; this can be done in
one line.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Find all markdown files in my blog directory&lt;/span&gt;
find my-blog-directory -type f -name &lt;span class="s2"&gt;&amp;quot;*.md&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can extend this command to do something else, for example, find all
instances in these files of the word "foo". Below, we build off our
previous command which found all markdown files in a directory by
adding the &lt;code&gt;-exec&lt;/code&gt; flag and specifying a command to run on each of the
files that &lt;code&gt;find&lt;/code&gt; finds.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Search markdown files for text &amp;quot;foo&amp;quot;&lt;/span&gt;
find my-blog-directory -type f -name &lt;span class="s2"&gt;&amp;quot;*.md&amp;quot;&lt;/span&gt; -exec grep &lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt; +
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;One kinda annoying thing about working with (UNIX) shell scripts is
that each (utility) program will have its own idiosyncratic syntax.
In the case of &lt;code&gt;find&lt;/code&gt;, you're going to specify options using &lt;code&gt;-thing&lt;/code&gt;
(in this example we specified the &lt;em&gt;type&lt;/em&gt; of thing we wanted to find
and a pattern for the &lt;em&gt;name&lt;/em&gt; to match).&lt;/p&gt;
&lt;p&gt;There is some additional special syntax here. When we run the &lt;code&gt;-exec
grep "foo" {} +&lt;/code&gt;, the &lt;code&gt;-exec {} +&lt;/code&gt; syntax tells &lt;code&gt;find&lt;/code&gt; to run the
given command (in this case &lt;code&gt;grep ...&lt;/code&gt; for each file found, where &lt;code&gt;{}&lt;/code&gt;
will be where the filename is inserted.&lt;/p&gt;
&lt;p&gt;As with natural language, fluent speakers don't spend all day thinking
about how grammar works while they are talking &lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt;. Instead, they
remember common patterns that they use frequently. Stuff like the
&lt;code&gt;find&lt;/code&gt; syntax above is confusing at first, but is something you will
get used to pretty quickly if you use it frequently.&lt;/p&gt;
&lt;h2&gt;Smashing Together More Things&lt;/h2&gt;
&lt;p&gt;The previous command we built up can be used to do all sorts of stuff
since &lt;code&gt;-exec +&lt;/code&gt; allows us to call &lt;em&gt;any program&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For example, let's suppose we wanted to get a whole bunch of YouTube
links to download and watch later. How do I get all the YouTube links
from my the markdown files in my blog directory?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Search markdown files for links to YouTube&lt;/span&gt;
find my-blog-directory -type f -name &lt;span class="s2"&gt;&amp;quot;*.md&amp;quot;&lt;/span&gt; -exec &lt;span class="se"&gt;\&lt;/span&gt;
grep -h -o &lt;span class="s2"&gt;&amp;quot;youtube\.com\/watch?v=[[:alnum:]]*&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt; +
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With &lt;code&gt;grep&lt;/code&gt; I used the &lt;code&gt;-h&lt;/code&gt; option to &lt;em&gt;hide&lt;/em&gt; the file name of the file
I'm currently searching and used the &lt;code&gt;-o&lt;/code&gt; option to &lt;em&gt;only&lt;/em&gt; show the
matched text, not the whole line of the regular expression I used.&lt;/p&gt;
&lt;p&gt;The output of this command can be saved into some file for further
processing.  For example, you can use &lt;code&gt;youtube-dl&lt;/code&gt; to help you
automatically download all the links you just collected while
you go do something else.&lt;/p&gt;
&lt;h2&gt;General Lessons from &lt;code&gt;find&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;You may find that after using shell scripts to do stuff for some time
you begin to think about how you can do things like naming files
consistently to make things like pattern matching via globbing easy.&lt;/p&gt;
&lt;p&gt;In the examples I gave above, I relied on file extensions (&lt;code&gt;.md&lt;/code&gt;) to
do my file finding. However I might want to process a bunch of files
starting with &lt;code&gt;my-diary-&lt;/code&gt;, for instance.&lt;/p&gt;
&lt;p&gt;Naming files and organizing directories in a way that makes sense for
easy processing is akin to setting up an SQL database with
well-planned tables; it may take more effort to start doing this
initially, but your efforts may be rewarded later down the road.&lt;/p&gt;
&lt;h2&gt;More links and resources&lt;/h2&gt;
&lt;p&gt;Relating to content discussed in this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.tecmint.com/35-practical-examples-of-linux-find-command/"&gt;35 Practical Examples of Linux Find
  Command&lt;/a&gt; (Ravi Saive 2012)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://linuxhint.com/bash_globbing_tutorial/"&gt;Bash Globbing Tutorial&lt;/a&gt; (Fahmida Yesmin 2018)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;For the most part, I'll be using &lt;code&gt;zsh&lt;/code&gt; and doing &lt;code&gt;bash&lt;/code&gt;
compatible things. The stuff I'm doing should all work on a pretty
default set-up with a major distribution (e.g. Debian, Arch) where
you can easily install common programs.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;See Luke Smith's video &lt;a href="https://www.youtube.com/watch?v=hMSByvFHOro"&gt;"Terminal vs. Bash vs. Command Line
vs. Prompt"&lt;/a&gt; (Dec. 2, 
2019) for clarification on terminology.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;I'm just going to use the word "Linux" here to describe a UNIX
computing environment where you can easily install certain common
programs. There is no time for me to quibble over GNU/Linux vs BSD
vs whatever!! Life is too short!!&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;After-hours linguistics discussions are OK.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Linux"></category></entry></feed>