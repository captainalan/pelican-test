<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Alan's Miscellaneous Stuff Blog - Linux</title><link href="https://captainalan.github.io/pelican-test/" rel="alternate"></link><link href="https://captainalan.github.io/pelican-test/feeds/linux.atom.xml" rel="self"></link><id>https://captainalan.github.io/pelican-test/</id><updated>2021-02-22T11:57:00-08:00</updated><entry><title>Law and Code, Impersonal systems</title><link href="https://captainalan.github.io/pelican-test/law-and-code-impersonal-systems.html" rel="alternate"></link><published>2021-02-22T11:57:00-08:00</published><updated>2021-02-22T11:57:00-08:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2021-02-22:/pelican-test/law-and-code-impersonal-systems.html</id><summary type="html">&lt;p&gt;Today I thought a bit about &lt;strong&gt;software licensing&lt;/strong&gt; mostly in simple human
terms&amp;mdash;I was thinking about this considering the fact that all widely used
pieces of software will contain software licenses in their &lt;strong&gt;source code&lt;/strong&gt;.
In what ways can we understand "law as code"?&lt;/p&gt;
&lt;h1&gt;Nerds just wanna coooooooooode&lt;/h1&gt;
&lt;p&gt;I …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Today I thought a bit about &lt;strong&gt;software licensing&lt;/strong&gt; mostly in simple human
terms&amp;mdash;I was thinking about this considering the fact that all widely used
pieces of software will contain software licenses in their &lt;strong&gt;source code&lt;/strong&gt;.
In what ways can we understand "law as code"?&lt;/p&gt;
&lt;h1&gt;Nerds just wanna coooooooooode&lt;/h1&gt;
&lt;p&gt;I think many people that get into software just like writing programs. With a
nice environment, it feels great to order symbols, seamlessly translating
thought into characters on the screen, which in turn can &lt;em&gt;do work&lt;/em&gt; even outside
of machines.&lt;/p&gt;
&lt;p&gt;Open Source and Free Software enthusiasts will be the first to tell you about
how licensing not only affects &lt;em&gt;which software you have to pay for&lt;/em&gt; (with US
Dollars or your favorite fiat currency), but perhaps more importantly &lt;em&gt;what
kind of software gets developed&lt;/em&gt;. That is, different licenses and approaches to
&lt;em&gt;software engineering&lt;/em&gt; lead to different sorts of projects &amp;amp; outcomes. &lt;/p&gt;
&lt;p&gt;Hobbyists (people that just like working with computers) will often have
attitudes like,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"I don't care if anyone re-uses my code if they find it useful"&lt;/li&gt;
&lt;li&gt;"I want to use software I can freely copy, modify, distribute, etc"&lt;/li&gt;
&lt;li&gt;"I have more trust in publicly available software that can be &lt;em&gt;audited&lt;/em&gt; by
  3rd party specialists"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On the other hand, business owners might have concerns like,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"I want to use software that is as inexpensive as possible"&amp;mdash;this not only
  includes paying for things like Windows licenses, it also includes stuff like
  &lt;em&gt;wages for employees&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;"I want to outsource/distribute risk if possible"&amp;mdash;if Microsoft or
  Google can deal with expensive security, this would often be preferable to
  dealing with the potentially very high legal costs of getting sued&lt;/li&gt;
&lt;li&gt;"I want to appeal to customers"&amp;mdash;a business owner might feel that
  choosing more established/conservative solutions is preferable to using
  cutting-edge tools as these things have been proven to deliver value to
  customers. On the other hand, a startup might try to appear to be
  "cutting-edge/ahead-of-the-curve" by adapting unconventional, experimental
  technologies.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We thus might find that hobbyists want to work with things that businesses
don't. Hobbyists might want decentralized, idiosyncratic setups while
businesses may opt for standardization (even if it means working with "boring
technology"). Businesses might not trust home-brewed solutions as much as
"official" solutions, even if a programmer could demonstrate how some Windows
setup or something is in many ways worse than some custom free software stack.&lt;/p&gt;
&lt;h1&gt;Law as a Platform&lt;/h1&gt;
&lt;p&gt;When talking computer stuff, you &lt;em&gt;must talk about "big tech"&lt;/em&gt; to understand the
shape stuff takes. For instance one reason someone might choose to use Windows
over Linux is because of &lt;strong&gt;hardware support&lt;/strong&gt;, often in the context of playing
games on a fancy graphics card or something. The software choice of Windows is
based indirectly on the fact that big companies like Microsoft, Intel and NVIDIA and
so forth can work together behind closed doors to make certain "stacks" (or
"configurations") perform better than others. You might only be able to "fully
utilize" some graphics card by running a handful of proprietary pieces of software.&lt;/p&gt;
&lt;p&gt;Legal considerations about what information you can/can't access is very
important for companies that fund research. Assuming some business is operating
to make money (and by extension gain power through market dominance), the big
companies that are able to fund research at big scale don't want to just
swallow all the costs of what they're doing without special benefits.&lt;/p&gt;
&lt;p&gt;Legal documents are a higher level of "code" underwhich instructions to
machines are written.&lt;/p&gt;
&lt;p&gt;You can think of programming as dealing with "legal documents" in different
scopes. For example, in Browser Land, people typically use JavaScript to
&lt;em&gt;govern&lt;/em&gt; what buttons do, maybe how some UI elements move around, and so on. In
"real life", you likewise have rules to determine stuff like &lt;em&gt;when trash gets
picked up&lt;/em&gt;. &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Both law and computer programming can be realms where &lt;em&gt;morality&lt;/em&gt; doesn't exist;
rather there is some other stinking pile of complications by which judgements can be made.
That is why there can be silly "legal loopholes" that "don't make sense". Code
might work but not be "elegant". In both cases, you have beastly systems that
are crucially &lt;strong&gt;impersonal&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The project of &lt;strong&gt;automation&lt;/strong&gt; is often doing something like taking &lt;em&gt;personal&lt;/em&gt;
aspects out of work (which could involve dishonesty, negligence) by putting
completely subservient machines in the place of human actors.&lt;/p&gt;
&lt;h2&gt;What protocols can(n't) guarantee&lt;/h2&gt;
&lt;p&gt;Consider the whole idea of a &lt;em&gt;protocol&lt;/em&gt;. We can guarantee data is transmitted
in a particular way with protols like HTTP; on the other hand, it would be very
difficult to get another person to correctly transmit some message
word-for-word orally.&lt;/p&gt;
&lt;p&gt;While we are able to guarantee some form of "data integrity", we clearly can't
ensure some message is effectively communicated if we consider actual
&lt;em&gt;meaning&lt;/em&gt;. We've all read things we didn't understand well, even if the
characters forming such-and-such texts were correctly transmitted.&lt;/p&gt;
&lt;p&gt;Thus we have law, code, and more in place to help remove error and make things
more effectively. But what often happens is we just created alternative, often
increasingly absurd systems that operate by &lt;em&gt;rules&lt;/em&gt;&amp;mdash;but these rules do
not necessarily "map to reality" to accomplish basic goals like "facilitating
communication" or "satisfying material needs" better than older, non-digital
technologies.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;It is not coincidental that many terms in computer stuff broadly
  correspond to "real world" analogs&amp;mdash;consider &lt;strong&gt;garbage collection&lt;/strong&gt; in
  relation to the previously stated analogy.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Linux"></category></entry><entry><title>Easy File Transfer with OpenSSH</title><link href="https://captainalan.github.io/pelican-test/easy-file-transfer-with-openssh.html" rel="alternate"></link><published>2021-02-14T00:00:00-08:00</published><updated>2021-02-14T00:00:00-08:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2021-02-14:/pelican-test/easy-file-transfer-with-openssh.html</id><summary type="html">&lt;p&gt;Today I learned that &lt;a href="https://www.openssh.com"&gt;OpenSSH&lt;/a&gt; allows you to easily
transfer files on a local network! I've started setting up some home network
stuff to learn how "the cloud" works better and was pleasantly surprised how
easy this was.&lt;/p&gt;
&lt;h2&gt;Setup&lt;/h2&gt;
&lt;p&gt;OpenSSH is the de-facto standard for remote access via &lt;code&gt;ssh&lt;/code&gt;. So …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Today I learned that &lt;a href="https://www.openssh.com"&gt;OpenSSH&lt;/a&gt; allows you to easily
transfer files on a local network! I've started setting up some home network
stuff to learn how "the cloud" works better and was pleasantly surprised how
easy this was.&lt;/p&gt;
&lt;h2&gt;Setup&lt;/h2&gt;
&lt;p&gt;OpenSSH is the de-facto standard for remote access via &lt;code&gt;ssh&lt;/code&gt;. So if you want to
log in from one computer to another, chances are you're going to be using
OpenSSH in 2021. &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;From a Linux machine, make sure you have a &lt;strong&gt;ssh server&lt;/strong&gt; set up. See the
section under &lt;strong&gt;Server usage&lt;/strong&gt; on the ArchWiki article on
&lt;a href="https://wiki.archlinux.org/index.php/OpenSSH"&gt;OpenSSH&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Filezilla&lt;/h2&gt;
&lt;p&gt;On Windows, I installed &lt;a href="https://filezilla-project.org"&gt;Filezilla&lt;/a&gt;. I entered
in the IP address of my home (Linux) server, my username and password and
selected the &lt;strong&gt;SFTP&lt;/strong&gt; protocol from Filezilla's easy to use GUI.
I could then easily copy files from my client (Windows) machine to my server
through my wireless network.&lt;/p&gt;
&lt;h2&gt;Alternatives to "the cloud"&lt;/h2&gt;
&lt;p&gt;Knowing how to do many "cloud computing" tasks yourself is a practical thing to
learn to take control of your data and understand the "magic" behind services
offered by big tech.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;This very blog post is being written from a Windows computer connected to
  a FreeBSD system via OpenSSH!&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Linux"></category></entry><entry><title>Restoring a user, practical Linux</title><link href="https://captainalan.github.io/pelican-test/restoring-a-user-practical-linux.html" rel="alternate"></link><published>2021-02-10T00:00:00-08:00</published><updated>2021-02-10T00:00:00-08:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2021-02-10:/pelican-test/restoring-a-user-practical-linux.html</id><summary type="html">&lt;p&gt;I am no Linux guru, but usually if I went to get something done I am
able to. In this post, I will document how I solved a particular
problem in a fast and easy way.&lt;/p&gt;
&lt;h2&gt;Problem: I really broke my system&lt;/h2&gt;
&lt;p&gt;I had a pretty old computer running Arch …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I am no Linux guru, but usually if I went to get something done I am
able to. In this post, I will document how I solved a particular
problem in a fast and easy way.&lt;/p&gt;
&lt;h2&gt;Problem: I really broke my system&lt;/h2&gt;
&lt;p&gt;I had a pretty old computer running Arch Linux. I was using Gnome as a
Desktop Environment and stuff was getting pretty slow. I tried to have
a boring, stable setup, but I ended up having a system that got hung
up a lot. So I wanted to remove Gnome and use a lighter-weight desktop
environment thing like LXDE or XFCE. Unfortunately, when uninstalling
Gnome, I did some reckless commands that also uninstalled a bunch of
important packages. So I ended up with a system that couldn't even
connect to the Internet to re-install those packages.&lt;/p&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;p&gt;My solution to this issue was to reinstall my base operating system
but leave my home directory intact. This way I could fix all the
things I wanted to fix and not have to go through some complicated
restoration procedure. While nothing super-important (or not already
backed up online) was on this computer, having to manually re-do a
bunch of configurations and stuff would be no fun, so it was
preferable to repair my existing system rather than starting anew.&lt;/p&gt;
&lt;h3&gt;Partitions helped&lt;/h3&gt;
&lt;p&gt;Fortunately, I had my system set up such that I had a separate root
(&lt;code&gt;/&lt;/code&gt;) and home (&lt;code&gt;/home&lt;/code&gt;) partition. So, it would not be too difficult
to isolate those things that needed fixing and those things that did
not.&lt;/p&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;I opted for installing &lt;strong&gt;Manjaro&lt;/strong&gt; Linux, an Arch-based distribution.
I downloaded the ISO, used Rufus on a Windows machine to set up a
bootable USB drive, and then entered the graphical installer. I chose
manual partitioning. Doing this, I had to set some "flags" (not sure
on the exact terminology here). Basically I had to tell the installer
where &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;/boot&lt;/code&gt; and &lt;code&gt;/home&lt;/code&gt; were. I reformatted my boot and root
partitions, but left the home partition as it was because I didn't
want to delete my files there.&lt;/p&gt;
&lt;h3&gt;User Stuff&lt;/h3&gt;
&lt;p&gt;That went smoothly. I just used the installer to make a new user. With
that new user, I created a user account for the main user I was using
on my old system using &lt;code&gt;useradd&lt;/code&gt;. As I didn't want Manjaro to add all
sorts of configuration stuff automatically, I chose to setup this new
user (I'll call it &lt;code&gt;alan&lt;/code&gt;) from the command line.&lt;/p&gt;
&lt;p&gt;I tried logging with &lt;code&gt;alan&lt;/code&gt; after doing this&amp;mdash;uh-oh! didn't
work. I was returned to Manjaro's login screen thing.&lt;/p&gt;
&lt;p&gt;I guessed the problem had to do with permissions. So, I searched up
how to change the permissions of my existing &lt;code&gt;/home/alan&lt;/code&gt; directory
which was left over from my broken install.&lt;/p&gt;
&lt;p&gt;Then, to make sure I could run any command from &lt;code&gt;alan&lt;/code&gt; via &lt;code&gt;sudo&lt;/code&gt;, I
needed to edit &lt;code&gt;/etc/sudoers&lt;/code&gt;. I did this with &lt;code&gt;sudo visudo
/etc/sudoers&lt;/code&gt; from the account I made with Manjaro. I uncommented the
line giving sudo permissions to the &lt;code&gt;wheel&lt;/code&gt; group and then I used
&lt;code&gt;usermod&lt;/code&gt; to add &lt;code&gt;alan&lt;/code&gt; to the &lt;code&gt;wheel&lt;/code&gt; group.&lt;/p&gt;
&lt;h3&gt;Success&lt;/h3&gt;
&lt;p&gt;I successfully logged on with &lt;code&gt;alan&lt;/code&gt;, installed some software, and
wrote this blog post. All my files and stuff are there.&lt;/p&gt;
&lt;h2&gt;Lessons&lt;/h2&gt;
&lt;p&gt;The specifics of how to do something in Linux can be mind-numbing. For
this reason, I don't even try to do lots of things&amp;mdash;like dealing
with audio and video issues. However, if you have a basic idea of what
you want to accomplish, doling common tasks like dealing with
partitions and users can be surprisingly easy.&lt;/p&gt;
&lt;p&gt;Search engines are good for solving technical problems. If you know
exactly what you want to search for, search engines are very good at
returning you relevant results. Fortunately, Linux problems often
involve weird strings (e.g. program names) that aren't confused with
non-computer things. Usually adding the word "linux" or "arch" or
something easily narrows a search to relevant stuff too.&lt;/p&gt;
&lt;p&gt;Through solving real world problems that come up, you can learn more
about how computers work, software is organized, and so on and so
forth. If you choose a lazy option like using an automatic installer
like I did here, you can avoid looking at many things you don't care
to struggle with too.&lt;/p&gt;</content><category term="Linux"></category></entry><entry><title>Modern UIs and the Rejection of Hierarchy</title><link href="https://captainalan.github.io/pelican-test/modern-uis-and-the-rejection-of-hierarchy.html" rel="alternate"></link><published>2020-12-16T00:00:00-08:00</published><updated>2020-12-16T00:00:00-08:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2020-12-16:/pelican-test/modern-uis-and-the-rejection-of-hierarchy.html</id><summary type="html">&lt;p&gt;I've been doing some listening/watching of Jonathan Pageau's &lt;a href="https://thesymbolicworld.com/"&gt;Symbolic
World&lt;/a&gt; content which has got me
thinking about symbols and meanings of lots of things around me. In
this post I want to share a brief analysis of &lt;em&gt;ways to interact with a
computer&lt;/em&gt; and how even in this area …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've been doing some listening/watching of Jonathan Pageau's &lt;a href="https://thesymbolicworld.com/"&gt;Symbolic
World&lt;/a&gt; content which has got me
thinking about symbols and meanings of lots of things around me. In
this post I want to share a brief analysis of &lt;em&gt;ways to interact with a
computer&lt;/em&gt; and how even in this area we see a &lt;em&gt;leveling of hierarchy&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;File Hierarchies&lt;/h2&gt;
&lt;p&gt;Those familiar with Linux or any UNIX based operating system will know
that the typical organization of a systems's files is hierarchical.
Typically there is soom &lt;em&gt;root&lt;/em&gt; denoted &lt;code&gt;/&lt;/code&gt;. Below that there is often
a directory &lt;code&gt;/home/&lt;/code&gt; under which users will have their personal files.
My user files are under &lt;code&gt;/home/alan/&lt;/code&gt;, for instance. Users can then
organize their files further with directories like
&lt;code&gt;/home/alan/Documents/&lt;/code&gt;, &lt;code&gt;/home/alan/Downloads/&lt;/code&gt; and so on and so
forth.&lt;/p&gt;
&lt;p&gt;Like a tree where each branch becomes a "mini tree" in a kind of
recursive process, we can see that individual projects/programs often
employ a similar structure. Using the &lt;code&gt;tree&lt;/code&gt; utility, for instance, I
can view the hierarchical structure this very file is found in.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;├── content&lt;/span&gt;
&lt;span class="err"&gt;│   ├── [...]&lt;/span&gt;
&lt;span class="err"&gt;│   ├── corona-virus-001.md&lt;/span&gt;
&lt;span class="err"&gt;│   ├── corona-virus-002.md&lt;/span&gt;
&lt;span class="err"&gt;│   ├── corona-virus-003.md&lt;/span&gt;
&lt;span class="err"&gt;│   ├── [...] &lt;/span&gt;
&lt;span class="err"&gt;│   ├── qwerty-theory.md&lt;/span&gt;
&lt;span class="err"&gt;│   ├── search-anarchy.md&lt;/span&gt;
&lt;span class="err"&gt;├── Makefile&lt;/span&gt;
&lt;span class="err"&gt;├── [...]&lt;/span&gt;
&lt;span class="err"&gt;├── README.md&lt;/span&gt;
&lt;span class="err"&gt;└── tasks.py&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Each file has its place. To use a &lt;strong&gt;static site generator&lt;/strong&gt; you must
put files in their correct place&amp;mdash;alongside other similar
files&amp;mdash;otherwise you probably won't get the result you're going
for &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;To become familiar with a system or software project, you will need to
learn &lt;em&gt;where to find everything&lt;/em&gt;. That is, &lt;em&gt;what are the positions in
the hierarchy&lt;/em&gt; and which files to go to in order to change the
program's behavior. A skilled developer or administrator will know
many quirks or tricks of some particular system.&lt;/p&gt;
&lt;p&gt;Skilled developers of course aim to make systems that are easy to
learn about and scale readily.&lt;/p&gt;
&lt;h2&gt;The Flattened Search-based Model&lt;/h2&gt;
&lt;p&gt;The MacBook tries to get rid of the need to understand file
hierarchies and become familiar with projects like in the examples
above. Using the Finder application, users simply &lt;em&gt;search&lt;/em&gt; and the
computer (rather than the user) is tasked with finding the relevant
files.&lt;/p&gt;
&lt;p&gt;You have probably met someone with a very messy (computer) desktop.
Today's powerpoint, last week's powerpoint, and e-mail attachments
from some party you probably don't need to know about all litter the
same (digital) space of the disordered desktop. For this sort of user,
the Finder approach provides much help&amp;mdash;nowdays, you might not
even need to choose meaningful &lt;em&gt;names&lt;/em&gt; for files because the Finder
application might search &lt;em&gt;within&lt;/em&gt; files and make up keywords based on
their contents. So &lt;code&gt;Unnamed document.docx&lt;/code&gt; might contain the words
"biology homework" and a search for "Biology" might be able to point
to this file even though the user didn't even bother to give it a
meaningful name.&lt;/p&gt;
&lt;p&gt;The Finder approach thus allows (or even &lt;em&gt;encourages&lt;/em&gt;) a sort of
"organizational bankruptcy"&amp;mdash;giving up on keeping stuff
well-ordered. You might as well dump everything into a folder called
"Stuff" and let Finder retrieve the appropriate file(s).&lt;/p&gt;
&lt;h2&gt;Smartphone App Prison&lt;/h2&gt;
&lt;p&gt;The smartphone app model involves making a kind of "jail" for each
thing you do&amp;mdash;an e-mail app, a music streaming app, a fitness
tracking app&amp;mdash;whereby &lt;em&gt;integrating&lt;/em&gt; data between the many things
you do is not easily done on a phone. Unlike on a desktop PC where you
might pull up a spreadsheet alongside a word processor and write up an
analysis or a report on last week's sales, the smartphone shafts most
things into one small self-contained video-game-like interface.&lt;/p&gt;
&lt;p&gt;There are some security and marketing advantages to this&amp;mdash;of
course you don't want your app getting compromised because of a
security flaw in someone else's app&amp;mdash;likewise you want to be able
to monetize &lt;em&gt;your&lt;/em&gt; product.&lt;/p&gt;
&lt;p&gt;But these advantages are more important for the &lt;em&gt;makers&lt;/em&gt; of the apps
rather than the &lt;em&gt;users&lt;/em&gt;. It shouldn't matter much where a good tool
comes from as long as it works well, and you shouldn't have to
constantly think about its special features&amp;mdash;it should seamlessly
facilitate your work as a kind of extension of your body.&lt;/p&gt;
&lt;p&gt;Apps invert this relationship whereby tools are an extension of your
body. Instead, &lt;em&gt;you&lt;/em&gt; become a &lt;em&gt;data point&lt;/em&gt; in an app's network. Rather
than you exercising agency over a tool, popular apps to gather usage
statistics on &lt;em&gt;you&lt;/em&gt; and charge &lt;em&gt;you&lt;/em&gt; for how you use the app. The tool
profits from you using it. You are the eyes, ears, and mouth of the
app&amp;mdash;the app makes you accept all liability for using it and can
be taken from you at any time.&lt;/p&gt;
&lt;h2&gt;Choosing tech, configuring for success&lt;/h2&gt;
&lt;p&gt;If you're not going to spend much time with technology, it probably
doesn't matter very much what you do. Most people I know, however, are
stuck using computers and phones for many hours a day&amp;mdash;especially
during all this COVID stuff. So we might as well get comfy with how to
best channel these devices to &lt;em&gt;work for us&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;PCs are often preferable to smart phones. A well-ordered desktop is
preferable to an indifferntiated pile of files and tools. Similar to
how you might choose to furnish a room for particular
purposes&amp;mdash;e.g. as a work room or as a dining room, we can also
set up your computing environments to encourage &lt;em&gt;time well spent&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;While many aspects of using computers can be annoying, simple
principles that would be applicable for organizing any workspace,
whether online or offline, can help you be more productive and focused
when using digital technology.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Here, all the files I wrote are in the &lt;strong&gt;Markdown&lt;/strong&gt; format
denoted by the &lt;code&gt;.md&lt;/code&gt; extension. To make a new blog entry, I simply
make a new markdown file, specify information like the title of my
blog post and the date, and then run scripts in the &lt;code&gt;Makefile&lt;/code&gt; to
&lt;em&gt;make&lt;/em&gt; my website.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Linux"></category></entry><entry><title>Creating a swap file</title><link href="https://captainalan.github.io/pelican-test/creating-a-swap-file.html" rel="alternate"></link><published>2020-05-25T00:00:00-07:00</published><updated>2020-05-25T00:00:00-07:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2020-05-25:/pelican-test/creating-a-swap-file.html</id><summary type="html">&lt;p&gt;Using old hardware, having &lt;strong&gt;swap&lt;/strong&gt; space in addition to RAM can make your
computer operate more smoothly.&lt;/p&gt;
&lt;h2&gt;From a fresh 'buntu Install&lt;/h2&gt;
&lt;p&gt;After a fresh Lubuntu on an old machine (with only 2 GB of RAM), I followed the
directions on &lt;a href="https://support.rackspace.com/how-to/create-a-linux-swap-file/"&gt;"Create a Linux swap
file"&lt;/a&gt;
(Rackspace 2018) to create …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Using old hardware, having &lt;strong&gt;swap&lt;/strong&gt; space in addition to RAM can make your
computer operate more smoothly.&lt;/p&gt;
&lt;h2&gt;From a fresh 'buntu Install&lt;/h2&gt;
&lt;p&gt;After a fresh Lubuntu on an old machine (with only 2 GB of RAM), I followed the
directions on &lt;a href="https://support.rackspace.com/how-to/create-a-linux-swap-file/"&gt;"Create a Linux swap
file"&lt;/a&gt;
(Rackspace 2018) to create a swap file &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;You can use the &lt;code&gt;htop&lt;/code&gt; command to see a summary of the processes running on
your computer in addition to CPU and memory usage.&lt;/p&gt;
&lt;h2&gt;On Arch Linux&lt;/h2&gt;
&lt;p&gt;Just check the Arch Wiki for the latest instrtuctions. I blindly followed the
directions above for Ubuntu and it didn't quite work.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Remember that Linux distributions are for the most part just bundled
  software and default configurations. Choosing Ubuntu (or some 'buntu
  "flavor") is an easy way to get a widely documented default setup going.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Linux"></category></entry><entry><title>Practical Shell Scripting, Part 3</title><link href="https://captainalan.github.io/pelican-test/practical-shell-scripting-part-3.html" rel="alternate"></link><published>2020-05-21T00:00:00-07:00</published><updated>2020-05-21T00:00:00-07:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2020-05-21:/pelican-test/practical-shell-scripting-part-3.html</id><summary type="html">&lt;p&gt;In this post, we will introduce &lt;code&gt;xargs&lt;/code&gt;, which allows you to pass in
arguments to a command via standard input.&lt;/p&gt;
&lt;p&gt;For example, to do&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; xargs ls -la
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;is like doing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ls &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; -la
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can think of &lt;code&gt;xargs&lt;/code&gt; as a kind of "keyword" or "syntactic feature"
of shell …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post, we will introduce &lt;code&gt;xargs&lt;/code&gt;, which allows you to pass in
arguments to a command via standard input.&lt;/p&gt;
&lt;p&gt;For example, to do&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; xargs ls -la
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;is like doing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ls &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; -la
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can think of &lt;code&gt;xargs&lt;/code&gt; as a kind of "keyword" or "syntactic feature"
of shell scripting since it gives us a general mechanism for combining
the inputs and outputs of various commands.&lt;/p&gt;
&lt;h2&gt;Use with &lt;code&gt;find&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;-exec&lt;/code&gt; option of &lt;code&gt;find&lt;/code&gt; can be cumbersome to work with as your
commands get more complex. In this example, &lt;code&gt;find&lt;/code&gt; is used to get text
files in the current directory, and then these files are passed to
&lt;code&gt;cat&lt;/code&gt; (and then printed to standard output) using &lt;code&gt;xargs&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;find . -maxdepth &lt;span class="m"&gt;1&lt;/span&gt; -type f -name &lt;span class="s2"&gt;&amp;quot;*.txt&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; xargs cat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Using various options of &lt;code&gt;find&lt;/code&gt; we can pass different stuff to
&lt;code&gt;xargs&lt;/code&gt;. Below, we find directories with names beginning with "Foo"
and use the &lt;code&gt;tree&lt;/code&gt; command to print textual tree representations of
these. This might be useful for copy/pasting a directory
representation to quickly show a collaborator how some project is laid
out.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;find . -maxdepth &lt;span class="m"&gt;1&lt;/span&gt; -type d -name &lt;span class="s2"&gt;&amp;quot;Foo*&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; xargs tree 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Using &lt;code&gt;find&lt;/code&gt; together with &lt;code&gt;xargs&lt;/code&gt; can be a useful pattern when you
have to repeat some action against on some files/directories that can
be found using parameters &lt;code&gt;find&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Storing Arguments in Text Files&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;xargs&lt;/code&gt; we can run commands based on data stored in text
files. This can be very convenient for separating data from the logic
of some script.&lt;/p&gt;
&lt;p&gt;Let's suppose you have some directory &lt;code&gt;media_to_consoom_later/&lt;/code&gt;. Here,
you queue up YouTube links like,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;youtube.com/video1&lt;/span&gt;
&lt;span class="err"&gt;youtube.com/video2&lt;/span&gt;
&lt;span class="err"&gt;youtube.com/video3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;...in a file called &lt;code&gt;youtube-videos.txt&lt;/code&gt;. You have another video
called &lt;code&gt;youtube-music.txt&lt;/code&gt; that follows the same format:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;youtube.com/track1&lt;/span&gt;
&lt;span class="err"&gt;youtube.com/track2&lt;/span&gt;
&lt;span class="err"&gt;youtube.com/track3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Using &lt;code&gt;xargs&lt;/code&gt; you can quickly execute two commands to download all the
videos with one set of options and then all the music files with
another. Here is an example usage with the program &lt;code&gt;youtube-dl&lt;/code&gt;, used
for downloading media off YouTube:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# No special options needed for video&lt;/span&gt;
cat youtube-videos-day1.txt youtube-videos-day2.txt &lt;span class="p"&gt;|&lt;/span&gt; xargs youtube-dl

&lt;span class="c1"&gt;# Use -x for &amp;#39;extract audio&amp;#39;&lt;/span&gt;
cat youtube-music.txt &lt;span class="p"&gt;|&lt;/span&gt; xargs youtube-dl -x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Storing lines like the ones above in a shell script file, you don't
have to remember all the flags/ettings for &lt;code&gt;youtube-dl&lt;/code&gt;, and you can
just drop in text links in an intuitive way into the appropriate text
files.&lt;/p&gt;
&lt;p&gt;This example too could be done with &lt;code&gt;find&lt;/code&gt;, matching &lt;code&gt;-name&lt;/code&gt; or some
other option as in,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# No special options needed for video&lt;/span&gt;
find . -name &lt;span class="s2"&gt;&amp;quot;youtube-videos*&amp;quot;&lt;/span&gt; -type f &lt;span class="p"&gt;|&lt;/span&gt; xargs youtube-dl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What is cool here is that you can separate the more complicated part
of what you're doing (e.g. setting up some options with &lt;code&gt;find&lt;/code&gt;;
reading some stuff from a file that may be created through a
complicated procedure) from a relatively simple command you want to
run (e.g. &lt;code&gt;youtube-dl&lt;/code&gt;). Editing the &lt;code&gt;...| xargs &amp;lt;COMMAND&amp;gt;&lt;/code&gt; is not so
bad even if the stuff that comes before it is difficult to figure out
the first time.&lt;/p&gt;</content><category term="Linux"></category></entry><entry><title>Practical Shell Scripting, Part 2</title><link href="https://captainalan.github.io/pelican-test/practical-shell-scripting-part-2.html" rel="alternate"></link><published>2020-05-20T00:00:00-07:00</published><updated>2020-05-20T00:00:00-07:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2020-05-20:/pelican-test/practical-shell-scripting-part-2.html</id><summary type="html">&lt;p&gt;In this post I will discuss a relatively straightforward command:
&lt;code&gt;cat&lt;/code&gt;.  The &lt;code&gt;cat&lt;/code&gt; command is used to &lt;em&gt;concatenate&lt;/em&gt; files. So if I had
three files, I could do something like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat file1.txt file2.txt file3.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;...and this would display the concatenated content of all these files
to standard …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post I will discuss a relatively straightforward command:
&lt;code&gt;cat&lt;/code&gt;.  The &lt;code&gt;cat&lt;/code&gt; command is used to &lt;em&gt;concatenate&lt;/em&gt; files. So if I had
three files, I could do something like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat file1.txt file2.txt file3.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;...and this would display the concatenated content of all these files
to standard output.&lt;/p&gt;
&lt;h2&gt;A Common Beginner's Mistake&lt;/h2&gt;
&lt;p&gt;Do not use &lt;code&gt;cat&lt;/code&gt; with just a single file, piping to another program.
You should instead just use that single file as input to the program
you were piping to.&lt;/p&gt;
&lt;p&gt;For example, rather than doing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Looking for where I talk about feelings in my_file.txt&lt;/span&gt;
cat my_file.txt &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;feelings&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;...you should just do,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Looking for where I talk about feelings in my_file.txt&lt;/span&gt;
grep &lt;span class="s2"&gt;&amp;quot;feelings&amp;quot;&lt;/span&gt; my_file.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There are efficiency reasons for doing things this way, but most
importantly you don't want to look silly in front of scoffing
neckbeards.&lt;/p&gt;
&lt;h2&gt;Some better uses of &lt;code&gt;cat&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;There are lots of places where it is good to have &lt;code&gt;cat&lt;/code&gt; around,
particularly where plain text files are being used&amp;mdash;&lt;code&gt;cat&lt;/code&gt;
probably won't be too useful manipulating images, dealing with audio
files, etc.&lt;/p&gt;
&lt;p&gt;However, dealing with little chunks of human readable text (such as in
log files, short scripts, etc.) &lt;code&gt;cat&lt;/code&gt; often comes in handy.&lt;/p&gt;
&lt;h3&gt;Entering short amounts of text really quickly&lt;/h3&gt;
&lt;p&gt;If you don't wanna open an editor, you can do&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat &amp;gt;&amp;gt; foo.txt &lt;span class="c1"&gt;# Append text fo foo.txt&lt;/span&gt;
cat &amp;gt; bar.txt  &lt;span class="c1"&gt;# Redirect (and replace) text fo bar.txt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Reading a bunch of stuff in &lt;code&gt;less&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;To view/read mixed files on one screen, you can do something like,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat file1.txt file2.txt file3.py &lt;span class="p"&gt;|&lt;/span&gt; less
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This could be useful for looking at a bunch of mixed/scattered
information in a directory at once, creating an on-the-fly "custom
view".&lt;/p&gt;
&lt;h2&gt;Organizing with &lt;code&gt;cat&lt;/code&gt; in mind&lt;/h2&gt;
&lt;p&gt;In this post, we looked at &lt;code&gt;cat&lt;/code&gt; which is not a terribly complicated
command.&lt;/p&gt;
&lt;p&gt;If you can remember what &lt;code&gt;cat&lt;/code&gt; does and also know when it is not so
useful, this is great! One less thing to look up!&lt;/p&gt;
&lt;p&gt;Knowing that you have &lt;code&gt;cat&lt;/code&gt; beside you and that you can likewise
expect it to available in nearly any UNIX environment you may find
yourself working in, you can create files knowing you might use &lt;code&gt;cat&lt;/code&gt;
with them.&lt;/p&gt;
&lt;p&gt;Suppose, for instance, you keep track of groceries to buy on in a
directory on your computer: &lt;code&gt;shopping/&lt;/code&gt;. You might have a series of files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vegetables.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;meat.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grains.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When you run out of lettuce, you might do &lt;code&gt;echo "lettuce" &amp;gt;&amp;gt;
vegetables.txt&lt;/code&gt; to quickly add an item to your TODO list.&lt;/p&gt;
&lt;p&gt;You can view various combinations of these lists using,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat vegetables.txt meat.txt &lt;span class="p"&gt;|&lt;/span&gt; less
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can also use your shell's globbing functions with commands like
&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat *.txt &lt;span class="c1"&gt;# hitting tab will autocomplete filenames&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What you have with cat is a kind of duct tape to smash files together
in many ways; this allows you to create "dynamic views" of textual
content. Combined with tools like &lt;code&gt;less&lt;/code&gt; (used for viewing text files
quickly) the possibilities are endless.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;This worked in &lt;code&gt;zsh&lt;/code&gt;; didn't try elsewhere yet&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Linux"></category></entry><entry><title>Practical Shell Scripting, Part 1</title><link href="https://captainalan.github.io/pelican-test/practical-shell-scripting-part-1.html" rel="alternate"></link><published>2020-05-19T00:00:00-07:00</published><updated>2020-05-19T00:00:00-07:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2020-05-19:/pelican-test/practical-shell-scripting-part-1.html</id><summary type="html">&lt;p&gt;In this series of articles, I will document how I do various things
using shell scripts&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.  My basic approach is to use &lt;code&gt;bash&lt;/code&gt; to
automate stuff by documenting and replicating steps that I take on the
&lt;strong&gt;Command Line Interface&lt;/strong&gt; (CLI) &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;Preliminary things&lt;/h2&gt;
&lt;p&gt;It is assumed the reader has …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this series of articles, I will document how I do various things
using shell scripts&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.  My basic approach is to use &lt;code&gt;bash&lt;/code&gt; to
automate stuff by documenting and replicating steps that I take on the
&lt;strong&gt;Command Line Interface&lt;/strong&gt; (CLI) &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;Preliminary things&lt;/h2&gt;
&lt;p&gt;It is assumed the reader has basic working knowledge of doing things
like navigating around directories, deleting files, using some editor,
etc. No knowledge is assumed of using specific tools like &lt;code&gt;find&lt;/code&gt;,
&lt;code&gt;xargs&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt;, etc. Much of the content here will be treating how to
do useful things using those tools.&lt;/p&gt;
&lt;h3&gt;Additional Setup&lt;/h3&gt;
&lt;p&gt;There is a utility called &lt;a href="https://www.shellcheck.net/"&gt;ShellCheck&lt;/a&gt;
which may be helpful to set up with your favorite editor/development
environment. This tool can help you find common mistakes in your shell
script code &lt;em&gt;before&lt;/em&gt; you even try to run it.&lt;/p&gt;
&lt;h3&gt;Methodology&lt;/h3&gt;
&lt;p&gt;When there is something that I want to do (on Linux), I'll try to do
it all via the command line. Anything non-trivial that I might have to
do again I'll want to document somewhere so I don't have to bother
figuring out the annoying aspects again. Comments can be written to
explain non-obvious choices.&lt;/p&gt;
&lt;h2&gt;Shell Scripts as Duct Tape&lt;/h2&gt;
&lt;p&gt;First, my "User Philosophy"!&lt;/p&gt;
&lt;p&gt;On your computer, you have many programs that can individually do
useful things. Shell scripting is the &lt;em&gt;de facto&lt;/em&gt; way to smash a bunch
of programs together to do more complex tasks for you.&lt;/p&gt;
&lt;p&gt;Shell scripting is different from "programing" in the sense that you
are often dealing with relatively high-level structures, understanding
&lt;em&gt;what&lt;/em&gt; programs do without needing to concern yourself with &lt;em&gt;how&lt;/em&gt; they
do it. In this way, you leave it up to the "real programers" to take
care of things like optimizing their programs to be efficient. Your
job is to just make sure that things hold together "good enough" with
duct tape.&lt;/p&gt;
&lt;p&gt;Over time you can refine your programs to be better. What is most
important is to get the job done and not get to hung up on what is
best. It is better to write more shell scripts, gradually learning
what is "best" among the many options to do things than to get hung up
on some esoteric problem too long.&lt;/p&gt;
&lt;p&gt;Careful engineering is the realm of using more full-featured,
complexity-friendly programing languages. You can write programs in
other languages and call them from shell-scripts if you have to do
something particularly complicated that your default tools cannot
handle so well (e.g. write a parser for a new custom file format you
created).&lt;/p&gt;
&lt;h2&gt;Where's my Search Bar?&lt;/h2&gt;
&lt;p&gt;MacOS has a fancy search feature you can use by pressing COMMAND+SPACE
by default. When you do this, you can type words, and MacOS will scan
your computer in who-knows-what-way for the text you are entering and
stuff the OS guesses might be related. Windows Explorer has similar
search features too, I think. How do you do something similar on
Linux? &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Suppose, we want to list all the Markdown files in a directory (&lt;code&gt;.md&lt;/code&gt;
extension). Using &lt;code&gt;find&lt;/code&gt; this can be done in
one line.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Find all markdown files in my blog directory&lt;/span&gt;
find my-blog-directory -type f -name &lt;span class="s2"&gt;&amp;quot;*.md&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can extend this command to do something else, for example, find all
instances in these files of the word "foo". Below, we build off our
previous command which found all markdown files in a directory by
adding the &lt;code&gt;-exec&lt;/code&gt; flag and specifying a command to run on each of the
files that &lt;code&gt;find&lt;/code&gt; finds.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Search markdown files for text &amp;quot;foo&amp;quot;&lt;/span&gt;
find my-blog-directory -type f -name &lt;span class="s2"&gt;&amp;quot;*.md&amp;quot;&lt;/span&gt; -exec grep &lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt; +
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;One kinda annoying thing about working with (UNIX) shell scripts is
that each (utility) program will have its own idiosyncratic syntax.
In the case of &lt;code&gt;find&lt;/code&gt;, you're going to specify options using &lt;code&gt;-thing&lt;/code&gt;
(in this example we specified the &lt;em&gt;type&lt;/em&gt; of thing we wanted to find
and a pattern for the &lt;em&gt;name&lt;/em&gt; to match).&lt;/p&gt;
&lt;p&gt;There is some additional special syntax here. When we run the &lt;code&gt;-exec
grep "foo" {} +&lt;/code&gt;, the &lt;code&gt;-exec {} +&lt;/code&gt; syntax tells &lt;code&gt;find&lt;/code&gt; to run the
given command (in this case &lt;code&gt;grep ...&lt;/code&gt; for each file found, where &lt;code&gt;{}&lt;/code&gt;
will be where the filename is inserted.&lt;/p&gt;
&lt;p&gt;As with natural language, fluent speakers don't spend all day thinking
about how grammar works while they are talking &lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt;. Instead, they
remember common patterns that they use frequently. Stuff like the
&lt;code&gt;find&lt;/code&gt; syntax above is confusing at first, but is something you will
get used to pretty quickly if you use it frequently.&lt;/p&gt;
&lt;h3&gt;Search a directory for text only using &lt;code&gt;grep&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Oftentimes, there is more than one way to do some task with common
shell utilities. The command below will find any occurence of "foo" in
any files recursively from the present directory (&lt;code&gt;.&lt;/code&gt;), informing you
which file the result was found in, the line number (&lt;code&gt;-n&lt;/code&gt; option), and
a preview of the line.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;grep . -rne &lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;"Idioms" like this are very nice for quickly doing stuff on the
command line. To compose such statements, you have to be careful about
the ordering of arguments, however.&lt;/p&gt;
&lt;p&gt;The above command can be broken up like so &lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5"&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;grep . -r -n -e &lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With the flags broken up like this, you can re-order stuff, e.g. like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;grep -e &lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; -rn .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Crucially, the "foo" (string you are searching) must follow the &lt;code&gt;-e&lt;/code&gt;
where it appears because the &lt;code&gt;-e&lt;/code&gt; tells &lt;code&gt;grep&lt;/code&gt; you are specifying an
expression to search.&lt;/p&gt;
&lt;h2&gt;Smashing Together More Things&lt;/h2&gt;
&lt;p&gt;The previous command we built up can be used to do all sorts of stuff
since &lt;code&gt;-exec +&lt;/code&gt; allows us to call &lt;em&gt;any program&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For example, let's suppose we wanted to get a whole bunch of YouTube
links to download and watch later. How do I get all the YouTube links
from my the markdown files in my blog directory?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Search markdown files for links to YouTube&lt;/span&gt;
find my-blog-directory -type f -name &lt;span class="s2"&gt;&amp;quot;*.md&amp;quot;&lt;/span&gt; -exec &lt;span class="se"&gt;\&lt;/span&gt;
grep -h -o &lt;span class="s2"&gt;&amp;quot;youtube\.com\/watch?v=[[:alnum:]]*&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt; +
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With &lt;code&gt;grep&lt;/code&gt; I used the &lt;code&gt;-h&lt;/code&gt; option to &lt;em&gt;hide&lt;/em&gt; the file name of the file
I'm currently searching and used the &lt;code&gt;-o&lt;/code&gt; option to &lt;em&gt;only&lt;/em&gt; show the
matched text, not the whole line of the regular expression I used.&lt;/p&gt;
&lt;p&gt;The output of this command can be saved into some file for further
processing.  For example, you can use &lt;code&gt;youtube-dl&lt;/code&gt; to help you
automatically download all the links you just collected while
you go do something else.&lt;/p&gt;
&lt;h2&gt;General Lessons from &lt;code&gt;find&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;You may find that after using shell scripts to do stuff for some time
you begin to think about how you can do things like naming files
consistently to make things like pattern matching via globbing easy.&lt;/p&gt;
&lt;p&gt;In the examples I gave above, I relied on file extensions (&lt;code&gt;.md&lt;/code&gt;) to
do my file finding. However I might want to process a bunch of files
starting with &lt;code&gt;my-diary-&lt;/code&gt;, for instance.&lt;/p&gt;
&lt;p&gt;Naming files and organizing directories in a way that makes sense for
easy processing is akin to setting up an SQL database with
well-planned tables; it may take more effort to start doing this
initially, but your efforts may be rewarded later down the road.&lt;/p&gt;
&lt;h2&gt;More links and resources&lt;/h2&gt;
&lt;p&gt;Relating to content discussed in this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.tecmint.com/35-practical-examples-of-linux-find-command/"&gt;35 Practical Examples of Linux Find
  Command&lt;/a&gt; (Ravi Saive 2012)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://linuxhint.com/bash_globbing_tutorial/"&gt;Bash Globbing Tutorial&lt;/a&gt; (Fahmida Yesmin 2018)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;For the most part, I'll be using &lt;code&gt;zsh&lt;/code&gt; and doing &lt;code&gt;bash&lt;/code&gt;
compatible things. The stuff I'm doing should all work on a pretty
default set-up with a major distribution (e.g. Debian, Arch) where
you can easily install common programs.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;See Luke Smith's video &lt;a href="https://www.youtube.com/watch?v=hMSByvFHOro"&gt;"Terminal vs. Bash vs. Command Line
vs. Prompt"&lt;/a&gt; (Dec. 2, 
2019) for clarification on terminology.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;I'm just going to use the word "Linux" here to describe a UNIX
computing environment where you can easily install certain common
programs. There is no time for me to quibble over GNU/Linux vs BSD
vs whatever!! Life is too short!!&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;After-hours linguistics discussions are OK.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;You could even expand the command argument names to the full
(unabbreviated) names if you wanted to be very verbose! Consult
your &lt;code&gt;man grep&lt;/code&gt; to see what those would be... Thanks &lt;code&gt;@Emily&lt;/code&gt; for
showing me this example of using &lt;code&gt;grep&lt;/code&gt; without &lt;code&gt;find&lt;/code&gt; to search
stuff!&amp;#160;&lt;a class="footnote-backref" href="#fnref:5" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Linux"></category></entry><entry><title>Why LARBS?</title><link href="https://captainalan.github.io/pelican-test/why-larbs.html" rel="alternate"></link><published>2019-12-27T00:00:00-08:00</published><updated>2019-12-27T00:00:00-08:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2019-12-27:/pelican-test/why-larbs.html</id><summary type="html">&lt;p&gt;In my &lt;a href="https://captainalan.github.io/pelican-test/arch-linux-install-for-n00bs.html"&gt;Arch Linux Install for n00bs&lt;/a&gt; I gave details on how to install Arch linux and then suggested &lt;a href="https://larbs.xyz"&gt;LARBS&lt;/a&gt; as a way to get up and running with your new installation. In this article I detail &lt;em&gt;why&lt;/em&gt; I find LARBS particularly useful and address some points brought up by …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In my &lt;a href="https://captainalan.github.io/pelican-test/arch-linux-install-for-n00bs.html"&gt;Arch Linux Install for n00bs&lt;/a&gt; I gave details on how to install Arch linux and then suggested &lt;a href="https://larbs.xyz"&gt;LARBS&lt;/a&gt; as a way to get up and running with your new installation. In this article I detail &lt;em&gt;why&lt;/em&gt; I find LARBS particularly useful and address some points brought up by haters.&lt;/p&gt;
&lt;h1&gt;Sensible Defaults&lt;/h1&gt;
&lt;p&gt;The number one reason to use LARBS is to experience with &lt;strong&gt;sensible defaults
for a keyboard centered workflow&lt;/strong&gt;. LARBS offers an out-of-the-box setup of
many nice things that can take a long time to set up manually: a &lt;strong&gt;tiling
window manager&lt;/strong&gt;, vi-like &lt;strong&gt;line editing&lt;/strong&gt; (via zsh), a PDF reader (Zathura).&lt;/p&gt;
&lt;p&gt;Furthermore, LARBS comes bundled with software you probably want: e.g. a
privacy-respecting browser (Brave), git, some programming languages and
compilers. The &lt;code&gt;yay&lt;/code&gt; tool is already setup to help you grab even more software
from Arch Linux's AUR repositories.&lt;/p&gt;
&lt;h3&gt;But &lt;em&gt;real&lt;/em&gt; Linux users set these things up themselves&lt;/h3&gt;
&lt;p&gt;Practical people want good tools readily available to them. If you begin
learning guitar on a really poorly made instrument you are more likely to
become discouraged and give up. On the other hand, if you have a more
experienced friend (or shop) set up your instrument when you are getting
started, you may make a lot more progress, more quickly in &lt;em&gt;actually learning
how to play&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Furthermore, many aspects of installing things randomly often are annoying and
don't involve much learning. The arcane details of how to run some program you
are probably going to run only very rarely are perhaps better offloaded to
automation (e.g. the shell scripts LARBS uses).&lt;/p&gt;
&lt;h3&gt;But using someone else's setup is lame!&lt;/h3&gt;
&lt;p&gt;LARBS does not constrain how you set things up later---it's just a shell script
to get you started.&lt;/p&gt;
&lt;p&gt;For instance, I use emacs a lot, and Luke Smith (who made LARBS) doesn't. Many
tools in LARBS I don't care about or use (e.g. &lt;code&gt;vifm&lt;/code&gt;, vim-like file manager)
because I just use &lt;code&gt;dired&lt;/code&gt; in emacs.&lt;/p&gt;
&lt;h1&gt;Pros and Cons&lt;/h1&gt;
&lt;h2&gt;What LARBS is &lt;em&gt;not&lt;/em&gt; good for&lt;/h2&gt;
&lt;p&gt;Obviously, if you require applications that require Windows or some other OS, you are out of luck.&lt;/p&gt;
&lt;p&gt;If you are doing complicated things with sound, hardware, etc. LARBS only gives a basic desktop setup. It may be much harder to adjust these settings in LARBS compared with a well-established Linux distribution, such as Lubuntu or Manjaro (two others I have tried with older hardware).&lt;/p&gt;
&lt;p&gt;It is hard to set up typing in CJK; I'm still figuring out how to get this well
integrated and will upload a guide when I am able to do so nicely.&lt;/p&gt;
&lt;h2&gt;What LARBS &lt;em&gt;is&lt;/em&gt; good for&lt;/h2&gt;
&lt;p&gt;LARBS is good for getting a decent general computing and programming
environment set up quickly.&lt;/p&gt;
&lt;p&gt;For a user coming from a more traditional desktop setup, LARBS allows you to
explore ideas like...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tiling windows for more efficient screen space usage&lt;/li&gt;
&lt;li&gt;Remapping CAPS LOCK for happier keyboarding&lt;/li&gt;
&lt;li&gt;Editing config files to change settings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;...without the trouble that might come from tweaking another installation (e.g.
modifying default Ubuntu) or doing everything from scratch.&lt;/p&gt;
&lt;p&gt;While on the one hand, there is definitely learning to be done in &lt;em&gt;doing&lt;/em&gt;
things yourself from the start, why shouldn't we reuse good defaults and stable
software set up by more knowledgable people? Studying the LARBS config files is
a good way to start writing your own configs.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;If you wanna try out a tilling window manager, just install Arch and LARBS. It
is not even that bad and you can customize it more later as you find out more
about what you want.&lt;/p&gt;</content><category term="Linux"></category></entry><entry><title>Getting Comfortable with Linux</title><link href="https://captainalan.github.io/pelican-test/getting-comfortable-with-linux.html" rel="alternate"></link><published>2019-08-14T00:00:00-07:00</published><updated>2019-08-14T00:00:00-07:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2019-08-14:/pelican-test/getting-comfortable-with-linux.html</id><summary type="html">&lt;p&gt;Updated 8/14/2019&lt;/p&gt;
&lt;h2&gt;This tutorial&lt;/h2&gt;
&lt;p&gt;This tutorial aims to answer this question:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Now that I have a Linux system running, how do I go about learning
more?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This tutorial is aimed at eager beginners and aspiring computer users
that have decided to take control of their computing. It largely …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Updated 8/14/2019&lt;/p&gt;
&lt;h2&gt;This tutorial&lt;/h2&gt;
&lt;p&gt;This tutorial aims to answer this question:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Now that I have a Linux system running, how do I go about learning
more?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This tutorial is aimed at eager beginners and aspiring computer users
that have decided to take control of their computing. It largely
follows my journey to learn more about Linux specifically and
computing more generally. My goal is that with this tutorial and a
handful of things downloaded, you can sit with your
computer&amp;mdash;even without an Internet connection and learn more
about computing.&lt;/p&gt;
&lt;p&gt;My approach here is thematic; I go over some class of actions you
might want to do, and then mention some options you may choose to
succeed at doing these things.&lt;/p&gt;
&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;p&gt;In this tutorial, I assume that you have a Linux system up and running
(...and here, the term "Linux" is used to mean a UNIX or UNIX-like
system that has certain core utilities, &lt;em&gt;not&lt;/em&gt; the kernel itself or
something highly technical like that). For something that just works,
&lt;a href="https://manjaro.org/"&gt;Manjaro&lt;/a&gt; and &lt;a href="https://xubuntu.org/"&gt;Xubuntu&lt;/a&gt;
are some solid options. If you want to spend some more time
configuring things, you may want to try &lt;a href="https://captainalan.github.io/pelican-test/"&gt;installing Arch
Linux&lt;/a&gt;. Really, it
doesn't matter that much where you start because you are entering
Linux land where customizability is king.&lt;/p&gt;
&lt;h3&gt;Editors&lt;/h3&gt;
&lt;p&gt;What is a samurai without a sword? You need an editor! Most things on
Linux are configurable via a &lt;strong&gt;"dot file"&lt;/strong&gt;, so called because they
have a name that starts with a &lt;em&gt;dot&lt;/em&gt; (e.g. &lt;code&gt;.bashrc&lt;/code&gt;,
&lt;code&gt;.eslint&lt;/code&gt;...). You will need an editor to change these files. If you
are enthusiastic about learning Linux, you probably have some interest
in writing scripts or programs or some sort. You'll need an editor for
that too.&lt;/p&gt;
&lt;p&gt;Learning the basics of some editor is a skill you will not
regret. Editors like &lt;code&gt;vi&lt;/code&gt; and &lt;code&gt;nano&lt;/code&gt; can be found pretty much
anywhere. It probably won't be too difficult for you to grab a more
sophisticated editor like &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;emacs&lt;/code&gt;, or Visual Studio Code.&lt;/p&gt;
&lt;h2&gt;The GUI way&lt;/h2&gt;
&lt;p&gt;There is a big movement to make Linux systems intuitive and
"user-friendly", particularly for users coming from Windows and
Mac. No explanations needed here&amp;mdash;you can explore the menus and
built in softwares with any Linux distribution that comes built in
with a graphical desktop environment. &lt;/p&gt;
&lt;p&gt;There is no shame in using and enjoying a GUI. For many things, this
is the easiest way to get things done, particularly if you don't care
to do any special configuration. Examples of things I've recently used
GUI menus to configure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Themes/fonts&lt;/li&gt;
&lt;li&gt;Wallpaper&lt;/li&gt;
&lt;li&gt;Keyboard shortcuts&lt;/li&gt;
&lt;li&gt;Joining wifi networks&lt;/li&gt;
&lt;li&gt;Sound/volume stuff&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Other tasks, such as managing software, is perhaps better done through
the Command Line Interface (CLI).&lt;/p&gt;
&lt;h2&gt;Whispering into the soul of your system&lt;/h2&gt;
&lt;p&gt;Lots of things on modern computers are "artifacts of engineering",
leftover remnants from designs of the past. One interesting example is
the "command line interface" typically accessed through a &lt;strong&gt;terminal&lt;/strong&gt;
(emulator).&lt;/p&gt;
&lt;p&gt;Computers used to look like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Computer Terminal" src="https://live.staticflickr.com/3708/10526021063_a47c368729_b.jpg"&gt;&lt;/p&gt;
&lt;p style="font-size: 0.9rem;font-style: italic;"&gt;&lt;a href="https://www.flickr.com/photos/15528623@N00/10526021063"&gt;"IMG_20131027_152921"&lt;/a&gt;&lt;span&gt;by &lt;a href="https://www.flickr.com/photos/15528623@N00"&gt;S. F.&lt;/a&gt;&lt;/span&gt; is licensed under &lt;a href="https://creativecommons.org/licenses/by-nc-sa/2.0/?ref=ccsearch&amp;atype=html" style="margin-right: 5px;"&gt;CC BY-NC-SA 2.0&lt;/a&gt;&lt;a href="https://creativecommons.org/licenses/by-nc-sa/2.0/?ref=ccsearch&amp;atype=html" target="_blank" rel="noopener noreferrer" style="display: inline-block;white-space: none;opacity: .7;margin-top: 2px;margin-left: 3px;height: 22px !important;"&gt;&lt;img style="height: inherit;margin-right: 3px;display: inline-block;" src="https://search.creativecommons.org/static/img/cc_icon.svg" /&gt;&lt;img style="height: inherit;margin-right: 3px;display: inline-block;" src="https://search.creativecommons.org/static/img/cc-by_icon.svg" /&gt;&lt;img style="height: inherit;margin-right: 3px;display: inline-block;" src="https://search.creativecommons.org/static/img/cc-nc_icon.svg" /&gt;&lt;img style="height: inherit;margin-right: 3px;display: inline-block;" src="https://search.creativecommons.org/static/img/cc-sa_icon.svg" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In more current times, the old way of interacting with computers is
emulated using what is usually called something like "terminal" or
"shell" on modern systems.&lt;/p&gt;
&lt;h3&gt;Need moar software&lt;/h3&gt;
&lt;p&gt;Most Linux distributions ship with a &lt;strong&gt;package manager&lt;/strong&gt;. &lt;/p&gt;
&lt;h3&gt;Exploring your filesystem&lt;/h3&gt;
&lt;p&gt;Typing stuff like &lt;code&gt;ls -la&lt;/code&gt; all the time can get very tiring. One way
to get around this problem is to define &lt;strong&gt;aliases&lt;/strong&gt; for commands you
commonly use.&lt;/p&gt;
&lt;p&gt;Another way to get around your file sytem is to use a &lt;strong&gt;file manager&lt;/strong&gt;
that runs on the command line (or within your favorite editor). For
example, there is &lt;a href="https://vifm.info/"&gt;&lt;code&gt;vifm&lt;/code&gt;&lt;/a&gt; for doing common
operations like moving, copying, and renaming files in a vim editor
like way. Emacs has the built in
&lt;a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html"&gt;&lt;code&gt;dired&lt;/code&gt;&lt;/a&gt;
mode to do these things.&lt;/p&gt;
&lt;h3&gt;Getting system info&lt;/h3&gt;
&lt;p&gt;To find out some quick information about your system and display it in
a pretty way, use your package manager to download and install
&lt;code&gt;screenfetch&lt;/code&gt;. There are of course other places to find all of this
information, but this is the easiest way to getting system info (that
also looks cool) akin to doing the "about my computer" stuff on
Windows or MacOS.&lt;/p&gt;
&lt;h2&gt;Finding more information&lt;/h2&gt;
&lt;p&gt;Are there things that you don't understand? How do you find
documentation for those things?&lt;/p&gt;
&lt;h3&gt;Clicking through menus&lt;/h3&gt;
&lt;p&gt;This is often how I learn more about the features of some program. You
may discover useful commands you never thought you needed if you take
the time to click through some menus.&lt;/p&gt;
&lt;p&gt;I've found this especially helpful in using widely used, large,
complex programs like GIMP (image manipulation) and Blender (3D
graphics).&lt;/p&gt;
&lt;h3&gt;Built-in help systems&lt;/h3&gt;
&lt;p&gt;Many pieces of software come with their own built in help
systems. Many (most?) users jump to searching the Internet for
answers, but becoming familiar with the built-in help system for some
software may be able to provide quicker, more specific answers if you
invest a little bit of time to learn how to use it.&lt;/p&gt;
&lt;p&gt;Documentation is often available for download for offline viewing. If
you have a 12 hour flight coming up, why not read a user manual until
you fall asleep? (either way, you win&amp;mdash;you learn something or you
get a good rest).&lt;/p&gt;
&lt;h3&gt;High quality online resources&lt;/h3&gt;
&lt;p&gt;Not all websites are created equal; finding the best websites can save
you a lot of time you'd otherwise spend sifting through crap.&lt;/p&gt;
&lt;p&gt;Rather than naïvely Googling how to do something on Linux, for
instance, it may be helpful to first consult the &lt;a href="https://wiki.archlinux.org/"&gt;Arch
Wiki&lt;/a&gt; for Linux related topics. This
resource can be useful even for non-Arch users that want to learn
about some topic and Linux. For instance, recently I wanted to see
what options were available for &lt;a href="https://wiki.archlinux.org/index.php/Optical_disc_drive#Ripping"&gt;ripping
CDs&lt;/a&gt;. The
Arch Wiki had lots of helpful information for doing that on my
(non-Arch) Debian-based system.&lt;/p&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://xahlee.info/linux/linux_index.html"&gt;Practical Linux Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="Linux"></category></entry><entry><title>Arch Linux Install for n00bs</title><link href="https://captainalan.github.io/pelican-test/arch-linux-install-for-n00bs.html" rel="alternate"></link><published>2019-06-02T00:00:00-07:00</published><updated>2019-06-02T00:00:00-07:00</updated><author><name>Alan Wong</name></author><id>tag:captainalan.github.io,2019-06-02:/pelican-test/arch-linux-install-for-n00bs.html</id><summary type="html">&lt;p&gt;(Last updated February 14, 2021)&lt;/p&gt;
&lt;p&gt;In this tutorial, I will go through installing Arch Linux. These
instructions were tried out on both a virtual machine and an old
laptop. For further instructions and details, I recommend &lt;em&gt;resisting
the urge to reflexively search everything&lt;/em&gt;, and instead taking the
time to read …&lt;/p&gt;</summary><content type="html">&lt;p&gt;(Last updated February 14, 2021)&lt;/p&gt;
&lt;p&gt;In this tutorial, I will go through installing Arch Linux. These
instructions were tried out on both a virtual machine and an old
laptop. For further instructions and details, I recommend &lt;em&gt;resisting
the urge to reflexively search everything&lt;/em&gt;, and instead taking the
time to read through high-quality resources, such as the (official)
Arch Wiki &lt;a href="https://wiki.archlinux.org/index.php/Installation_guide"&gt;installation
guide&lt;/a&gt;.  That
being said, the content in this article should be sufficient to get an
Arch System up and running&amp;em;I've used it multiple times to help me
setup new systems.&lt;/p&gt;
&lt;p&gt;I am closely following &lt;a href="https://www.youtube.com/watch?v=4PBqpX0_UOc"&gt;Full Arch Linux Install (SAVAGE Edition!)
Linux&lt;/a&gt; by Luke Smith (March 8,
2018).&lt;/p&gt;
&lt;p&gt;We will do a base installation of Arch Linux. Then we'll run &lt;a href="https://lukesmith.xyz"&gt;Luke
Smith's&lt;/a&gt; &lt;a href="https://larbs.xyz/"&gt;LARBS&lt;/a&gt; script to
get an awesome i3 tiling window manager setup from the outset.  (TODO:
Also -&amp;gt; Add instructions/links to a &lt;strong&gt;NEW&lt;/strong&gt; tutorial about getting a
Desktop Environment, emacs, etc. and choosing a different path).&lt;/p&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;This tutorial is aimed at people with some exposure to Linux and/or command
line tools (e.g. using &lt;code&gt;brew&lt;/code&gt; under MacOS), but who would like to gain
greater control of their current computing setups. Here, I honor the maxim
that &lt;em&gt;knowledge is power&lt;/em&gt; and seek to empower you by getting you started
using Arch Linux and understanding the tools that you are using.&lt;/p&gt;
&lt;p&gt;You should know how to do basic things with &lt;code&gt;vi&lt;/code&gt; (or &lt;code&gt;vim&lt;/code&gt;, or some
other editor readily available in the
&lt;a href="https://en.wikipedia.org/wiki/Computer_terminal#Text_terminals"&gt;TTY&lt;/a&gt;,
such as &lt;code&gt;nano&lt;/code&gt;) because doing an Arch install will involve editing
some text files on the command line.&lt;/p&gt;
&lt;h2&gt;Installation Medium&lt;/h2&gt;
&lt;p&gt;Download the latest Arch linux ISO. The easiest thing to do is probably to
download from an HTTP mirror near your (physical) location and then install by
CD, DVD, or USB.&lt;/p&gt;
&lt;p&gt;From Windows, creating your installation medium is easy. Right click
on the downloaded &lt;code&gt;.iso&lt;/code&gt; file and select "Burn disc image" to create
CD or DVD to create a your installation medium. Alternatively, you can
use &lt;a href="https://rufus.ie/"&gt;Rufus&lt;/a&gt; on Windows to create install media on
USB drives, SD cards, and more.&lt;/p&gt;
&lt;h2&gt;Booting with the installation medium&lt;/h2&gt;
&lt;p&gt;Restart your computer. You may have to go into your system BIOS to make sure you can boot from your installation medium.&lt;/p&gt;
&lt;h3&gt;Get an internet connection&lt;/h3&gt;
&lt;p&gt;If you are already connected to the Internet via an ethernet cable, there is
nothing to think about. &lt;/p&gt;
&lt;p&gt;If you are connecting via Wi-Fi, there may be some more steps to take. &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;
First, run &lt;code&gt;iwctl&lt;/code&gt; see &lt;a href="https://wiki.archlinux.org/index.php/Iwd"&gt;ArchWiki&lt;/a&gt; for
mroe specifics. Find your wireless card. You may have to scan for networks
multiple times.&lt;/p&gt;
&lt;h3&gt;Time and date stuff&lt;/h3&gt;
&lt;p&gt;Run &lt;code&gt;timedatectl set-ntp true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note the 'prefix' &lt;em&gt;-ctl&lt;/em&gt; in the command above. Commands with &lt;em&gt;-ctl&lt;/em&gt;
have to do with &lt;em&gt;controlling&lt;/em&gt; system processes. A command we will see
later is
&lt;a href="https://wiki.archlinux.org/index.php/Systemd#Basic_systemctl_usage"&gt;&lt;code&gt;systemctl&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Partitioning your drive(s)&lt;/h2&gt;
&lt;p&gt;Now, let's partition our disks. &lt;strong&gt;Note&lt;/strong&gt;: I am assuming you are
installing Arch Linux on a computer you are OK with deleting all data
on. Go reboot and back up your files and stuff if you are not ready to
proceed yet.&lt;/p&gt;
&lt;p&gt;In any case you can, run &lt;code&gt;lsblk&lt;/code&gt; (or &lt;code&gt;fdisk -l&lt;/code&gt;) to "list all block
devices".&lt;/p&gt;
&lt;h3&gt;Creating new partitions&lt;/h3&gt;
&lt;p&gt;From &lt;code&gt;lsblk&lt;/code&gt;, you can identify the drive you want to install Arch Linux on.
This will probably be &lt;code&gt;/dev/sda&lt;/code&gt; if you are installing onto an old computer.&lt;/p&gt;
&lt;p&gt;Let's start changing things.  To begin, type &lt;code&gt;fdisk /dev/sda&lt;/code&gt;, where
'"&lt;code&gt;sda&lt;/code&gt;" corresponds to the &lt;strong&gt;drive&lt;/strong&gt; you wish to create a new
partition table on (don't do &lt;code&gt;fdisk /dev/sda123&lt;/code&gt;; this won't
work&amp;em;go ahead and try that if you don't believe me!).&lt;/p&gt;
&lt;p&gt;You will now be sent to a new prompt that looks something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Command (m for help):&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If there are existing partitions you may need to type &lt;code&gt;d&lt;/code&gt; to delete them.
Type &lt;code&gt;p&lt;/code&gt; to print partitions. Once you are done deleting existing stuff, type
&lt;code&gt;n&lt;/code&gt; at the prompt to make a new partition.&lt;/p&gt;
&lt;p&gt;We will now create the following partitions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boot partition (200MB)&lt;/li&gt;
&lt;li&gt;SWAP partition (how much RAM you have, times 1.5)&lt;/li&gt;
&lt;li&gt;Root (25 GB or more)&lt;/li&gt;
&lt;li&gt;Home (everything else)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After typing &lt;code&gt;n&lt;/code&gt;, you will be be prompted with a number of options. To create
the Boot partition, accept the first default option (&lt;code&gt;p&lt;/code&gt;) to create a new
primary partition. Accept &lt;code&gt;1&lt;/code&gt; as the default partition number. Accept the
default "First sector" location. For the "Last sector", enter &lt;code&gt;+200M&lt;/code&gt;. This means will be the &lt;em&gt;boot&lt;/em&gt; partition which we are allocating 200 MB for.&lt;/p&gt;
&lt;p&gt;Next, we will create a &lt;strong&gt;swap partition&lt;/strong&gt;. Type &lt;code&gt;n&lt;/code&gt; again to get started.
Standard practice is to create a swap partition of about 1.5-2 times the
amount of RAM you have. I'll be using 4 GB for this. Accept the default
partion number (probably 2), default first sector, and for the last sector do
&lt;code&gt;+4G&lt;/code&gt; (where you replace "4" with however much memory you select for your
swap partition).&lt;/p&gt;
&lt;p&gt;We will now create a &lt;strong&gt;root partition&lt;/strong&gt; where all your programs will be
installed. A reasonable starting size for this is around 25 GB, though you
may need more if you like to install a lot of programs. I'll be using 64 GB.
Typing &lt;code&gt;n&lt;/code&gt; (and then pressing Enter), I accept the default for the partiton
number and the starting sector and then select &lt;code&gt;+64G&lt;/code&gt; for the last sector.&lt;/p&gt;
&lt;p&gt;Finally, we need to create a &lt;strong&gt;home partition&lt;/strong&gt; which will take up the rest
of your disk. Do &lt;code&gt;n&lt;/code&gt; for a new partition and then selct &lt;code&gt;p&lt;/code&gt; (rather than &lt;code&gt;e&lt;/code&gt;)
to create a new primary partition. Then, accept all the defaults that follow.&lt;/p&gt;
&lt;p&gt;We have now created four nice partitions using &lt;code&gt;fdisk&lt;/code&gt;. However, these are
not "commited" to disk yet. Write &lt;code&gt;w&lt;/code&gt; at the &lt;code&gt;Command (m for help):&lt;/code&gt; prompt
to write your partitions to your disk. Note that this will wipe everything on the disk.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; since we partitioned our disk, you can easily install a different linux distribution if you wanted; just re-write the &lt;code&gt;root&lt;/code&gt; partition and all your &lt;code&gt;home&lt;/code&gt; files will still be there.&lt;/p&gt;
&lt;p&gt;Type &lt;code&gt;lsblk&lt;/code&gt; to see how &lt;code&gt;fdisk&lt;/code&gt; changed your harddirve.&lt;/p&gt;
&lt;h2&gt;Making filesystems&lt;/h2&gt;
&lt;p&gt;We just partitioned our disks, but we need to set &lt;strong&gt;filesystems&lt;/strong&gt; to our
partitions.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;boot&lt;/code&gt;, &lt;code&gt;root&lt;/code&gt;, and &lt;code&gt;home&lt;/code&gt; partition (&lt;code&gt;sda1&lt;/code&gt;, &lt;code&gt;sda3&lt;/code&gt;, and &lt;code&gt;sda4&lt;/code&gt; if you
have been following the tutorial for) should be formatted to &lt;code&gt;ext4&lt;/code&gt;, a Linux
standard.&lt;/p&gt;
&lt;p&gt;Do &lt;code&gt;mkfs.ext4 /dev/sda1&lt;/code&gt;, &lt;code&gt;mkfs.ext4 /dev/sda3&lt;/code&gt;, and &lt;code&gt;mkfs.ext4 /dev/sda4&lt;/code&gt; to
set these partitions' filesystems.&lt;/p&gt;
&lt;p&gt;Now, for the swap partition do &lt;code&gt;mkswap /dev/sda2&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Mounting stuff&lt;/h2&gt;
&lt;p&gt;Now that we have created partitions with appropriate filesystems, we need to
&lt;strong&gt;mount&lt;/strong&gt; things.&lt;/p&gt;
&lt;p&gt;First, do &lt;code&gt;mount /dev/sda3 /mnt&lt;/code&gt; to mount your root partition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; at any point during this tutorial you may want to run &lt;code&gt;lsblk&lt;/code&gt; to see
*how your disks currently look.&lt;/p&gt;
&lt;p&gt;Type &lt;code&gt;ls /mnt&lt;/code&gt;. You should see something like &lt;code&gt;lost+found&lt;/code&gt; there.&lt;/p&gt;
&lt;p&gt;Let's make make some new directories to mount stuff. First do
&lt;code&gt;mkdir /mnt/boot&lt;/code&gt; create a mount point for our boot partition. Then, run
&lt;code&gt;mount /dev/sda1 /mnt/boot&lt;/code&gt; to do the actual mounting.&lt;/p&gt;
&lt;p&gt;Finally, do &lt;code&gt;mkdir /mnt/home&lt;/code&gt;. Run &lt;code&gt;mount /dev/sda4 /mnt/home&lt;/code&gt; to mount your
home partition.&lt;/p&gt;
&lt;h2&gt;Installing the base system&lt;/h2&gt;
&lt;p&gt;We now have all of our partitions and have mounted these partitions on our
file systems. Mounting allows us to modify the data on these partitions,
which means we can install softare (like Arch Linux!).&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;lsblk&lt;/code&gt; to see that all is as it should be.&lt;/p&gt;
&lt;h3&gt;The fun starts with &lt;code&gt;pacstrap&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Run &lt;code&gt;pacstrap /mnt base base-devel&lt;/code&gt; to install the base package and basic
development tools. If you want more things, add them like so to this command.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update December 8, 2019&lt;/strong&gt;: You may want to also install &lt;code&gt;linux&lt;/code&gt; and
&lt;code&gt;linux-firmware&lt;/code&gt; to make sure the latest Linux kernel and appropriate drivers
respectively are installed. Do this &lt;em&gt;before&lt;/em&gt; you install &lt;code&gt;grub&lt;/code&gt; (directions
below) or else you may not be able to boot your new installation.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pacstrap /mnt base base-devel linux linux-firmware neovim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Running this command might take a while because it is installing an entire
base system.&lt;/p&gt;
&lt;h2&gt;Making an &lt;code&gt;fstab&lt;/code&gt; file&lt;/h2&gt;
&lt;p&gt;Earlier, we mounted a bunch of partitions manually. An &lt;code&gt;fstab&lt;/code&gt; file tells
Linux what to try to load (see &lt;code&gt;etc/fstab&lt;/code&gt;). Run &lt;code&gt;genfstab /mnt&lt;/code&gt;. This will
generate an &lt;code&gt;fstab&lt;/code&gt; file based on how &lt;code&gt;mnt&lt;/code&gt; looks. Running this command will
just output a bunch of stuff.&lt;/p&gt;
&lt;p&gt;If you made a swap partition earlier and you don't see it here, you should do
&lt;code&gt;swapon /dev/sdaX&lt;/code&gt; (replace &lt;code&gt;/dev/sdaX&lt;/code&gt; with your swap partition of course). If
you're going to use a &lt;strong&gt;swap file&lt;/strong&gt; later, don't worry about this now&amp;mdash;
you can edit things later.&lt;/p&gt;
&lt;p&gt;We need to save these things to a file. Run
&lt;code&gt;genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now Arch Linux will know what goes where.&lt;/p&gt;
&lt;h2&gt;Making our installation bootable&lt;/h2&gt;
&lt;p&gt;Run &lt;code&gt;arch-chroot /mnt&lt;/code&gt; to change our root. This will change our Arch root to
our new &lt;code&gt;/mnt&lt;/code&gt; directory! Before, we were running from our installation
medium, now we are running from our actual installation!&lt;/p&gt;
&lt;h3&gt;I needs Interwebs&lt;/h3&gt;
&lt;p&gt;Let's install some stuff. First, let's install &lt;code&gt;NetworkManager&lt;/code&gt; by typing &lt;code&gt;pacman -S networkmanager&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, type &lt;code&gt;systemctl enable NetworkManager&lt;/code&gt; to start &lt;code&gt;NetworkManager&lt;/code&gt;
whenever you log in.&lt;/p&gt;
&lt;h3&gt;GRUB Bootloader&lt;/h3&gt;
&lt;p&gt;Run &lt;code&gt;pacman -S grub&lt;/code&gt; to install GRUB, our bootloader. This is important!&lt;/p&gt;
&lt;p&gt;After this finishes, run &lt;code&gt;grub-install --target=i386-pc /dev/sda&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Once this is done, do &lt;code&gt;grub-mkconfig -o /boot/grub/grub.cfg&lt;/code&gt; to make a config
file. (This might be done automatically.)&lt;/p&gt;
&lt;h3&gt;Setting a password&lt;/h3&gt;
&lt;p&gt;Run &lt;code&gt;passwd&lt;/code&gt; to set a root password.&lt;/p&gt;
&lt;h3&gt;Setting a locale&lt;/h3&gt;
&lt;p&gt;Use your text editor (here I use &lt;code&gt;vim&lt;/code&gt;) to edit &lt;code&gt;/etc/locale.gen&lt;/code&gt;. I do this
with &lt;code&gt;vim /etc/locale.gen&lt;/code&gt;. In this huge list of locales I uncommented&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#en_US.UTF-8 UTF-8&lt;/span&gt;
&lt;span class="err"&gt;#en_US ISO-8859-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;to...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;en_US.UTF-8 UTF-8&lt;/span&gt;
&lt;span class="err"&gt;en_US ISO-8859-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;...in order to set my locale. Note, you can set multiple languages. Save and
exit this file.&lt;/p&gt;
&lt;p&gt;Next, run &lt;code&gt;locale-gen&lt;/code&gt; to read the conf file you just edited and generate a
file.&lt;/p&gt;
&lt;p&gt;Let's edit one more file to set our (default) language: &lt;code&gt;vim
/etc/locale.conf&lt;/code&gt;. I changed the contents of this file to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;LANG=en_US.UTF-8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Setting a timezone&lt;/h3&gt;
&lt;p&gt;By default, in &lt;code&gt;/etc/localtime&lt;/code&gt;, there are a bunch of time zones. We want to
link &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt; with our timezone.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;ln -sf /usr/share/zoneinfo/America/Los_Angeles /etc/localtime&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;...where of course you replace &lt;code&gt;.../America/Los_Angles...&lt;/code&gt; with where you are.&lt;/p&gt;
&lt;p&gt;If you travel somewhere else, you will rerun the &lt;code&gt;ln...&lt;/code&gt; command here to the
timezone of wherever you are going.&lt;/p&gt;
&lt;h3&gt;Setting a hostname&lt;/h3&gt;
&lt;p&gt;Finally, you need to set a name for your computer. Edit &lt;code&gt;/etc/hostname&lt;/code&gt; to
whatever you like. I will do &lt;code&gt;vim /etc/hostname&lt;/code&gt; and enter &lt;code&gt;arch-sama&lt;/code&gt; for a (weeby) hostname.&lt;/p&gt;
&lt;h3&gt;Going back to your installation medium...&lt;/h3&gt;
&lt;p&gt;Type &lt;code&gt;exit&lt;/code&gt; to go back to your installation medium.&lt;/p&gt;
&lt;p&gt;Then, to be safe type &lt;code&gt;umount -R /mnt&lt;/code&gt; to unmount your Arch installation (on
your harddrive).&lt;/p&gt;
&lt;h3&gt;Reboot!&lt;/h3&gt;
&lt;p&gt;Type &lt;code&gt;reboot&lt;/code&gt;. Remove your installation medium. You should boot to your new
installation.&lt;/p&gt;
&lt;h2&gt;(Optional) LARBS&lt;/h2&gt;
&lt;p&gt;Here is the easy part. To get a pretty cool configuration right away, use
Luke Smith's &lt;a href="https://larbs.xyz"&gt;LARBS&lt;/a&gt; setup.&lt;/p&gt;
&lt;p&gt;Booting your new Arch setup, login as &lt;code&gt;root&lt;/code&gt;. You'll be prompted for your
password.&lt;/p&gt;
&lt;p&gt;Next, run&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;curl -LO larbs.xyz/larbs.sh  &lt;span class="c1"&gt;# Download the script&lt;/span&gt;
bash larbs.sh                &lt;span class="c1"&gt;# Run the script you just downloaded!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Logging in&lt;/h3&gt;
&lt;p&gt;Login with the username and password you set in LARBS. To modify your system,
you'll probably need to use &lt;code&gt;su&lt;/code&gt; and the password you set for root in the
Arch install.&lt;/p&gt;
&lt;h3&gt;Troubleshooting LARBS install&lt;/h3&gt;
&lt;p&gt;If you aren't connected to the Internet, this step can be a pain in the ass.
Search the Arch Wiki for wisdom.&lt;/p&gt;
&lt;p&gt;If you run into issues with &lt;code&gt;xorg&lt;/code&gt;, search for answers related to your graphics
card. Using an older (around 2010) laptop with an NVIDIA graphics card, I had
to install the Nouveau drivers.&lt;/p&gt;
&lt;h2&gt;Checking your new system out&lt;/h2&gt;
&lt;p&gt;Make sure your &lt;code&gt;/etc/fstab&lt;/code&gt; came out correctly.&lt;/p&gt;
&lt;p&gt;Running &lt;code&gt;htop&lt;/code&gt; I found out that my SWAP partition wasn't being used
after following the above steps. Easy way to get SWAP working was to
install gparted (&lt;code&gt;sudo pacman -Syu gparted&lt;/code&gt;) and launch that (&lt;code&gt;sudo
gparted&lt;/code&gt;), then make sure the swap partiton I created had &lt;code&gt;SWAPON&lt;/code&gt;
(find option in menus). You can then &lt;code&gt;sudo swapon --show&lt;/code&gt; to see that
things are working correctly.&lt;/p&gt;
&lt;h3&gt;Hard Drive Related Troubleshooting&lt;/h3&gt;
&lt;h3&gt;Boot issues&lt;/h3&gt;
&lt;p&gt;In this article, I used an "old-school" style of partitioning drives, mounting
partitions, etc.  If you are having trouble booting, you may need to go into
your BIOS to make sure you are booting devices in the correct order. You may
also want to check that your &lt;code&gt;/boot&lt;/code&gt; directory (mounted to its own partition,
hopefully) is bootable. Look up how to add a boot &lt;strong&gt;flag&lt;/strong&gt; to do this. Two ways
are to use the &lt;code&gt;fdisk&lt;/code&gt; util introduced at the beginning of this tutorial, or do
get an install for another distro (e.g. Ubuntu) and use the graphical tools
(e.g. gparted) to assist you in doing that.&lt;/p&gt;
&lt;h4&gt;Messed up partitons?&lt;/h4&gt;
&lt;p&gt;I used the article "&lt;a href="https://www.tecmint.com/move-home-directory-to-new-partition-disk-in-linux/"&gt;move your home directory to a new partiton&lt;/a&gt;" as a guide. The same approach here can be used for all sorts of directory and partition shuffling.&lt;/p&gt;
&lt;p&gt;The basic procedure to move your &lt;code&gt;/home/&lt;/code&gt; to a new partition is to&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;create a new partition,&lt;/li&gt;
&lt;li&gt;copy your existing &lt;code&gt;/home&lt;/code&gt; directory there and verify this operation succeeded,&lt;/li&gt;
&lt;li&gt;remove the old files you just copied,&lt;/li&gt;
&lt;li&gt;mount the copied files on the correct (new) partition to &lt;code&gt;/home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;save your configuration in &lt;code&gt;/etc/fstab&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These operations will require &lt;code&gt;su&lt;/code&gt; permissions (e.g. through using &lt;code&gt;sudo&lt;/code&gt;).&lt;/p&gt;
&lt;h2&gt;(Optional) Next Steps&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(Add directions for setting up a user, &lt;code&gt;sudo&lt;/code&gt; privileges)&lt;/li&gt;
&lt;li&gt;(Add directions for getting a window manager; getting some starter fonts)&lt;/li&gt;
&lt;li&gt;(Add basic shell setup)&lt;/li&gt;
&lt;li&gt;(Add directions for setting up &lt;code&gt;yay&lt;/code&gt; or another AUR helper)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;(Update February 14, 2021) Formerly, this was easier&amp;mdash;you could just
  run &lt;code&gt;wifi-menu&lt;/code&gt;. Now it seems this program isn't available in the installer.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Linux"></category></entry></feed>