title: Law and Code, Impersonal systems
date: 2021-02-22 11:57
category: Linux

Today I thought a bit about **software licensing** mostly in simple human
terms&mdash;I was thinking about this considering the fact that all widely used
pieces of software will contain software licenses in their **source code**.
In what ways can we understand "law as code"?

Nerds just wanna coooooooooode
==============================

I think many people that get into software just like writing programs. With a
nice environment, it feels great to order symbols, seamlessly translating
thought into characters on the screen, which in turn can *do work* even outside
of machines.

Open Source and Free Software enthusiasts will be the first to tell you about
how licensing not only affects *which software you have to pay for* (with US
Dollars or your favorite fiat currency), but perhaps more importantly *what
kind of software gets developed*. That is, different licenses and approaches to
*software engineering* lead to different sorts of projects & outcomes. 

Hobbyists (people that just like working with computers) will often have
attitudes like,

- "I don't care if anyone re-uses my code if they find it useful"
- "I want to use software I can freely copy, modify, distribute, etc"
- "I have more trust in publicly available software that can be *audited* by
  3rd party specialists"

On the other hand, business owners might have concerns like,

- "I want to use software that is as inexpensive as possible"&mdash;this not only
  includes paying for things like Windows licenses, it also includes stuff like
  *wages for employees*
- "I want to outsource/distribute risk if possible"&mdash;if Microsoft or
  Google can deal with expensive security, this would often be preferable to
  dealing with the potentially very high legal costs of getting sued
- "I want to appeal to customers"&mdash;a business owner might feel that
  choosing more established/conservative solutions is preferable to using
  cutting-edge tools as these things have been proven to deliver value to
  customers. On the other hand, a startup might try to appear to be
  "cutting-edge/ahead-of-the-curve" by adapting unconventional, experimental
  technologies.

We thus might find that hobbyists want to work with things that businesses
don't. Hobbyists might want decentralized, idiosyncratic setups while
businesses may opt for standardization (even if it means working with "boring
technology"). Businesses might not trust home-brewed solutions as much as
"official" solutions, even if a programmer could demonstrate how some Windows
setup or something is in many ways worse than some custom free software stack.

Law as a Platform
=================

When talking computer stuff, you *must talk about "big tech"* to understand the
shape stuff takes. For instance one reason someone might choose to use Windows
over Linux is because of **hardware support**, often in the context of playing
games on a fancy graphics card or something. The software choice of Windows is
based indirectly on the fact that big companies like Microsoft, Intel and NVIDIA and
so forth can work together behind closed doors to make certain "stacks" (or
"configurations") perform better than others. You might only be able to "fully
utilize" some graphics card by running a handful of proprietary pieces of software.

Legal considerations about what information you can/can't access is very
important for companies that fund research. Assuming some business is operating
to make money (and by extension gain power through market dominance), the big
companies that are able to fund research at big scale don't want to just
swallow all the costs of what they're doing without special benefits.

Legal documents are a higher level of "code" underwhich instructions to
machines are written.

You can think of programming as dealing with "legal documents" in different
scopes. For example, in Browser Land, people typically use JavaScript to
*govern* what buttons do, maybe how some UI elements move around, and so on. In
"real life", you likewise have rules to determine stuff like *when trash gets
picked up*. [^1]

Both law and computer programming can be realms where *morality* doesn't exist;
rather there is some other stinking pile of complications by which judgements can be made.
That is why there can be silly "legal loopholes" that "don't make sense". Code
might work but not be "elegant". In both cases, you have beastly systems that
are crucially **impersonal**.

The project of **automation** is often doing something like taking *personal*
aspects out of work (which could involve dishonesty, negligence) by putting
completely subservient machines in the place of human actors.

What protocols can(n't) guarantee
---------------------------------

Consider the whole idea of a *protocol*. We can guarantee data is transmitted
in a particular way with protols like HTTP; on the other hand, it would be very
difficult to get another person to correctly transmit some message
word-for-word orally.

While we are able to guarantee some form of "data integrity", we clearly can't
ensure some message is effectively communicated if we consider actual
*meaning*. We've all read things we didn't understand well, even if the
characters forming such-and-such texts were correctly transmitted.

Thus we have law, code, and more in place to help remove error and make things
more effectively. But what often happens is we just created alternative, often
increasingly absurd systems that operate by *rules*&mdash;but these rules do
not necessarily "map to reality" to accomplish basic goals like "facilitating
communication" or "satisfying material needs" better than older, non-digital
technologies.

[^1]: It is not coincidental that many terms in computer stuff broadly
  correspond to "real world" analogs&mdash;consider **garbage collection** in
  relation to the previously stated analogy.
