title: Corona Virus Diary, Part 103
date: 2021-02-17
category: News

You may have heard that it is often better to *start slow* and *learn
correctly* first rather than jumping to (overly) advanced learning.
How is it that we find out what it is to *learn correctly?* In modern times,
sometimes this is tricky.

With respect to technology stuff, there are endless details one might master.
For instance, if someone says that they are going to study some
"coding/programming", this could mean any number of *bossing around machines*,
generally. Probably the first coding I did was trying out some exercise in a
book; for others it was programming graphic calculators. I don't think the
"entry" into programming matters so much&mdash;

There seem to be distinguishing marks between good vs bad (or skilled vs
unskilled) **technologists**, regardless of specifics of technology.
Anybody can copy and paste some code or go through a tutorial to reproduce some
results someone else designed&mdash;similarly, it is not too difficult to
follow a recipe or tutorial video to cook some dish *once*.

Experience & results as a measure of success
--------------------------------------------

What distinguishes a more skilled technical practioner is being able to adapt
some (familiar) toolset to whatever problems/demands arise. For some things,
like web programming, it may be necessary to learn more tools/techniques as
approaches people take change. A skilled coder will know not to get too caught
up in any one technique because experience teaches how transient fads in
technology are. [^1]

A distinguishing feature of people that have at some point *enjoyed* working
with technology is that they experienced a sense of freedom "experimenting" or
"hacking" with their tools. This sort of person tends to enjoy a kinda
"reward/feedback" loop, writing more and more programs (or equivalently with
other tech, using some toolset like a hammer and nails) and thus&mdash;given
adequate self-criticism/awareness&mdash;iterative improvement.  
On the other hand, a "purist" might get too obsessed with some one *thing* that
prevents them from making progress. Let's suppose a person early on decides that
"I will be a *python* programmer". Well, this might work out for a while, but
what happens if/when python specifically falls out of a favor? [^2]

An experienced and skilled technologist will be able to recognize what is
really new/different and what is just marketing or unhelpful abstraction.
For example, in the world of web programming, there are a lot of different "Web
Frameworks" which give various ways to smash together HTML, CSS, and JavaScript
which are the fundamental "building blocks" of the (front end) web. You might learn
some new system like **Angular** or **React** in order to *generate* a site
that is HTML, CSS, and JavaScript "under the hood". Now, anyone skilled in
using one of these frameworks will tell you that having a good grasp of the
*basic* underlying HTML/CSS/JavaScript is essential for knowing what the
framework can and can't do. You need to understand *why* big tech companies
invested so much money into developing these frameworks&mdash;without a good
understanding of the *problems* some tool is supposed to solve, it is hard to
make good use of it.

We typically don't say "I'm going to practice *using a pencil*" or "I'm going
to go do *hammer exercises*". Rather, we'd practice handwriting/drawing or
building fences or have some other more concrete goal.

Without some kind of goal, it is hard to tell if we're getting better at what
we're doing or if we're just going in circles becoming increasingly
idiosyncratic but not any more effective. Clearly, you can spend lots and lots
of time doing *something* that nobody ever asked you to do&mdash;many aspiring
"creative" types may pour hours and hours into some projects nobody asked for.
Are they getting better at what they do?

Some way of evaluating stuff is needed to make progress.

Thus the heading here, *experience & results as a measure of success*.
The skilled technical practioner can't progress in increasing their skill if
they cease to work by building stuff.

Regaining focus
---------------

There are some underlying technologies that change slower than
others. Understanding the essentials of "base" underlying technologies can be
thought of as the tech equivalent to "returning to fundamentals" and thus
locating the things that need to be *learned correctly*.

By learning some basic things well, it is much easier to get to the
*comfortably building* stuff phase as opposed to the *recipe look-up phase*.
Like learning to write stuff, we first learn how to combine smaller parts, and
then we find that we can piece together increasingly longer-form pieces.

One way I have lost a lot of time (and focus) is by getting too caught up in
over-complicated tooling/configurations. Back in the day, I think this was less
of a problem as the early computer users couldn't really complicate computing
beyond how complicated it was inherently&mdash;you might have *no choices* with
regard to which programming language was available to use with your machine!
Now, you can find **listicle** upon listicle comparing/ranking your many, many
choices of programming language, database, cloud service, etc.

I'm finding a useful heuristic is to *ignore* these and turn instead to,

- What is the market demanding? You can learn technologies based on what you
  know people will pay for
- Learning fundamentals; the more (useful) technologies they are common to, the
  better
- Understand *problems* before (proposed/complex) solutions&mdash;this is to
  say, *know what sort of thing you want to build and why* before getting too
  attached to some new tooling/technique

I'll use "computer stuff" as a case study.  If you are doing any kind of
software development, chances are you're going to be using `git` for source
control. It would probably be a good idea to learn some of that well (enough).
Similarly, all over the Open Source software world, you see UNIX/Linux stuff
everywhere&mdash;probably most of the tools used today are connected with this
tradition. So it makes sense to get comfy with how people have used these
systems to do stuff for a long while.  Learning terminal/command-line stuff
might seem archaic and overly complicated until you understand what problems it
solves and how it is useful&mdash;first try interacting with any remote system;
chances are you will need `ssh`. You will find that learning all these
text-based commands is really useful for describing and repeating actions.
Compared with something like GUI-based mouse motion recording, you can see that
a whole class of problems&mdash;such as how big your monitor is&mdash;vanish as
dimensionality is collapsed.

Sometimes, we have too many opinions 
------------------------------------

Knowing a little bit about a whole bunch of different things is a quick way to
become a scatter-brained, opinion filled person. Is this a good state of affairs?
For getting stuff done, it probably isn't. It would be better if you were more
effective at acting in the world and had no time for endless opinion spouting
(or perhaps even worse, being butthurt because other people don't listen to or
respect your opinions).

Thinking that you are right, it can be hard to see this in oneself&mdash;surely
I have all these opinions because *I know what I'm talking about!*

I think it is better to just get good at what you do. Therefore, by sheer
results, others will go do you and *ask you how you got your results*. Your
opinions will be *solicited* rather than *unsolicited*.

nobody is making u read my blog, btw... lol :D

[^1]: Note that the people who *make* tools aren't usually the same people who
  use them. Making swords is different from being a practicing swordsman;
  likewise with lots of technology stuff, domains like computer science
  (theory), hardware, making software libraries, writing applications, and
  setting up IT infrastucture may involve very different day-to-day activities.
[^2]: Xah Lee's [Computing and Its
  People](http://xahlee.info/comp/comp_index.html) essays/links offer many
  insights into interactions between people, technologies, and
  business&mdash;e.g. which programing languages have succeeded and why?
